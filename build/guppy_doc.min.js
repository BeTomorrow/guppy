(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GuppyDoc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
   @class
   @classdesc A class representing a Guppy document
   @param {string} [doc=<m><e></e></m>] - An XML string representing the document
   @constructor 
 */
var GuppyDoc = function(doc){
    doc = doc || "<m><e></e></m>";
    this.set_content(doc);
}

GuppyDoc.prototype.is_small = function(nn){
    var n = nn.parentNode;
    while(n != null && n.nodeName != 'm'){
	if(n.getAttribute("small") == "yes") return true;
	n = n.parentNode
	while(n != null && n.nodeName != 'c') n = n.parentNode;
    }
    return false;
}

GuppyDoc.prototype.ensure_text_nodes = function(){
    var l = this.base.getElementsByTagName("e");
    for(var i = 0; i < l.length; i++){
	if(!(l[i].firstChild)) l[i].appendChild(this.base.createTextNode(""));
    }
}

/** 
    Check if document is empty
    @memberof GuppyDoc
    @returns {boolean}
*/
GuppyDoc.prototype.is_blank = function(){
    if(this.base.getElementsByTagName("f").length > 0) return false;
    var l = this.base.getElementsByTagName("e");
    if(l.length == 1 && (!(l[0].firstChild) || l[0].firstChild.textContent == "")) return true;
    return false;
}


/** 
    Get the document as a DOM object
    @memberof GuppyDoc
    @returns {Element}
*/
GuppyDoc.prototype.root = function(){
    return this.base.documentElement;
}

/** 
    Get the content of the document as a string
    @memberof GuppyDoc
    @param {string} t - The rendering method to use ("latex", "text", "ast" (for syntax tree), or "xml" (for internal XML representation))
    @returns {string}
*/
GuppyDoc.prototype.get_content = function(t,r){
    if(t == "xml") return (new XMLSerializer()).serializeToString(this.base);
    else if(t == "ast") return JSON.stringify(this.syntax_tree());
    else return this.manual_render(t,this.root(),r);
}

GuppyDoc.prototype.syntax_tree = function(n){
    n = n || this.root()
    if(n.nodeName == "e"){
	console.log("Should never happen");
	//ans = n.firstChild.textContent;
    }
    else if(n.nodeName == "f"){
	var ans = {"args":[], "kwargs":{}};
	ans['value'] = n.getAttribute("type");
	ans['type'] = "function";
	if(n.hasAttribute("ast_value")) ans['value'] = n.getAttribute("ast_value");
	if(n.hasAttribute("ast_type")) ans['type'] = n.getAttribute("ast_type");
	else if(n.getAttribute("char") == "yes") ans['type'] = "name";
	
	var iterator = this.xpath_list("./*[name()='c' or name()='l']", n)
	for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext()){
	    if(nn.hasAttribute("name")) ans.kwargs[nn.getAttribute("name")] = this.syntax_tree(nn)
	    else ans.args.push(this.syntax_tree(nn))
	}
    }
    else if(n.nodeName == "l"){
	ans = [];
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans.push(this.syntax_tree(nn));
	}
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	var tokens = []
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    if(nn.nodeName == "e"){
		tokens = tokens.concat(GuppyDoc.tokenise(nn.firstChild.textContent));
	    }
	    else if(nn.nodeName == "f"){
		tokens.push(this.syntax_tree(nn));
	    }
	}
	ans = GuppyDoc.parse(tokens);
    }
    return ans;
}

GuppyDoc.prototype.xpath_node = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

GuppyDoc.prototype.xpath_list = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
}

/** 
    Get the names of symbols used in this document
    @memberof GuppyDoc
    @param {string[]} [groups] - A list of groups you want strings for
    @returns {string[]}
*/
GuppyDoc.prototype.get_symbols = function(groups){
    var types = {};
    var ans = [];
    var iterator = groups ? this.xpath_list("//f") : this.xpath_list("//f[@group='"+groups[i]+"']");
    for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext())
	types[nn.getAttribute("type")] = true;
    for(var t in types)
	ans.push(t);
    return ans;
}

/** 
    Set the content of the document
    @memberof GuppyDoc
    @param {string} xml_data - An XML string representing the content of the document
*/
GuppyDoc.prototype.set_content = function(xml_data){
    this.base = (new window.DOMParser()).parseFromString(xml_data, "text/xml");
    this.ensure_text_nodes();
}

GuppyDoc.bracket_xpath = "(count(./*) != 1 and not \
		          ( \
                            count(./e)=2 and \
			    count(./f)=1 and \
			    count(./e[string-length(text())=0])=2 and \
			    ( \
			      (\
                                count(./f/c)=1 and\
			        count(./f/c[@is_bracket='yes'])=1\
			      )\
			      or\
			      (\
			        f/@c='yes' and \
				count(./e[@current='yes'])=0 and \
				count(./e[@temp='yes'])=0 \
			      )\
			    )\
			  )\
			)  \
			or\
		        (\
			  count(./*) = 1 and \
			  string-length(./e/text()) != 1 and \
			  number(./e/text()) != ./e/text() \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@current = 'yes' \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@temp = 'yes' \
			)"

GuppyDoc.prototype.manual_render = function(t,n,r){
    var ans = "";
    if(n.nodeName == "e"){
	if(t == "latex" && r){
	    ans = n.getAttribute("render");
	}
	else if(t == "text"){
	    ans = n.firstChild.textContent;
	    if(n.previousSibling && n.nextSibling && ans == "")
		ans = " * ";
	    else {
		ans = ans.replace(/(.)([^a-zA-Z0-9.])(.)/g,"$1 $2 $3");
		ans = ans.replace(/([a-zA-Z])(?=\.)/g,"$1 * ");
		ans = ans.replace(/(\.)(?=[a-zA-Z])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z])(?=[a-zA-Z0-9])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z0-9])(?=[a-zA-Z])/g,"$1 * ");
		if(n.previousSibling && n.previousSibling.getAttribute("group") != "operations") ans = ans.replace(/^([a-zA-Z0-9])/g," * $1");
		if(n.nextSibling && n.nextSibling.getAttribute("group") != "operations") ans = ans.replace(/([a-zA-Z0-9])$/g,"$1 * ");
		ans = " "+ans+" ";
	    }
	}
	else{
	    ans = n.firstChild.textContent;
	}
    }
    else if(n.nodeName == "f"){
	var real_type = (t == "latex" && this.is_small(n)) ? "small_latex" : t;
	var nn = this.xpath_node("./b[@p='"+real_type+"']", n) || this.xpath_node("./b[@p='"+t+"']", n);
	if(nn) ans = this.manual_render(t,nn,r);
    }
    else if(n.nodeName == "b"){
	var cs = []
	var i = 1;
	var par = n.parentNode;
	for(var nn = par.firstChild; nn != null; nn = nn.nextSibling)
	    if(nn.nodeName == "c" || nn.nodeName == "l") cs[i++] = this.manual_render(t,nn,r);
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    if(nn.nodeType == 3) ans += nn.textContent;
	    else if(nn.nodeType == 1){
		if(nn.hasAttribute("d")){
		    var dim = parseInt(nn.getAttribute("d"));
		    var joiner = function(d,l){
			if(d > 1) for(var k = 0; k < l.length; k++) l[k] = joiner(d-1,l[k]);
			return l.join(nn.getAttribute('sep'+(d-1)));
		    }
		    ans += joiner(dim,cs[parseInt(nn.getAttribute("ref"))]);
		}
		else ans += cs[parseInt(nn.getAttribute("ref"))];
	    }
	}
    }
    else if(n.nodeName == "l"){
	ans = [];
	var i = 0;
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans[i++] = this.manual_render(t,nn,r);
	}
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling)
	    ans += this.manual_render(t,nn,r);
	if(t == "latex" &&
           n.getAttribute("bracket") == "yes" &&
	   this.base.evaluate(GuppyDoc.bracket_xpath, n, null,
			 XPathResult.BOOLEAN_TYPE, null).booleanValue){ 
	    ans = "\\left("+ans+"\\right)";
	}
    }
    return ans;
}

GuppyDoc.prototype.path_to = function(n){
    var name = n.nodeName;
    if(name == "m") return "guppy_loc_m";
    var ns = 0;
    for(var nn = n; nn != null; nn = nn.previousSibling) if(nn.nodeType == 1 && nn.nodeName == name) ns++;
    return this.path_to(n.parentNode)+"_"+name+""+ns;
}

GuppyDoc.tokenise = function(s){
    var tokens = [
	{"type":"number", "re":"^[0-9]+(\\.[0-9]+)?", "value":function(m){return Number(m)}},
	{"type":"operator", "re":"^[\-+*/!]", "value":function(m){return m}},
	{"type":"name", "re":"^[a-zA-Z]", "value":function(m){return m}},
	{"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ];
    var ans = [];
    while(s.length > 0){
	var ok = false;
	for(var i = 0; i < tokens.length; i++){
	    var t = tokens[i];
	    re = RegExp(t.re);
	    var m = re.exec(s);
	    if(m){
		m = m[0];
		s = s.substring(m.length);
		ok = true;
		if(t.type != "space") ans.push({"type":t.type, "value": t.value(m)})
		break;
	    }
	}
	if(!ok){
	    console.log("Tokenising error");
	    return [];
	}
    }
    return ans;
}

GuppyDoc.parse = function(tokens){
    var symbol_table = {};

    var original_symbol = {
	nud: function () { throw Error("Undefined"); },
	led: function (left) { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
	var s = symbol_table[id];
	bp = bp || 0;
	if (s) {
            if (bp >= s.lbp) {
		s.lbp = bp;
            }
	} else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
	}
	return s;
    };

    symbol("(end)");

    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(function)", 60);
    s.led = mul;
    s.nud = function(){ return [this.value, this.args || [], this.kwargs || {}];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){ return ["var", [this.value]] };

    var token;
    var token_nr = 0;

    var advance = function (id) {
	var a, o, t, v;
	if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
	}
	if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
	}
	t = tokens[token_nr];
	token_nr += 1;
	v = t.value;
	var args = null;
	var kwargs = null;
	a = t.type;
	if (a === "name") {
            o = symbol_table["(var)"];
	} else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
		t.error("Unknown operator.");
            }
	} else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
	} else if (a ===  "function") {
            a = "function";
            o = symbol_table["(function)"];
	    args = t.args;
	    kwargs = t.kwargs;
	} else {
            throw Error("Unexpected token",t);
	}
	token = Object.create(o);
	token.type = a;
	token.value = v;
	if(args) token.args = args;
	if(kwargs) token.kwargs = kwargs;
	return token;
    };


    var expression = function (rbp) {
	var left;
	var t = token;
	advance();
	left = t.nud();
	while (rbp < token.lbp) {
            t = token;
            advance();
            left = t.led(left);
	}
	return left;
    };

    var infix = function (id, bp, led) {
	var s = symbol(id, bp);
	s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
	};
	return s;
    }

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    var prefix = function (id, nud) {
	var s = symbol(id);
	s.nud = nud || function () {
            return [this.value, [expression(70)]];
	};
	return s;
    }

    prefix("-");
    prefix("!");
    prefix("typeof");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}

module.exports = GuppyDoc;

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsInNyYy9ndXBweV9kb2MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICAgQGNsYXNzXG4gICBAY2xhc3NkZXNjIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgR3VwcHkgZG9jdW1lbnRcbiAgIEBwYXJhbSB7c3RyaW5nfSBbZG9jPTxtPjxlPjwvZT48L20+XSAtIEFuIFhNTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkb2N1bWVudFxuICAgQGNvbnN0cnVjdG9yIFxuICovXG52YXIgR3VwcHlEb2MgPSBmdW5jdGlvbihkb2Mpe1xuICAgIGRvYyA9IGRvYyB8fCBcIjxtPjxlPjwvZT48L20+XCI7XG4gICAgdGhpcy5zZXRfY29udGVudChkb2MpO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUuaXNfc21hbGwgPSBmdW5jdGlvbihubil7XG4gICAgdmFyIG4gPSBubi5wYXJlbnROb2RlO1xuICAgIHdoaWxlKG4gIT0gbnVsbCAmJiBuLm5vZGVOYW1lICE9ICdtJyl7XG5cdGlmKG4uZ2V0QXR0cmlidXRlKFwic21hbGxcIikgPT0gXCJ5ZXNcIikgcmV0dXJuIHRydWU7XG5cdG4gPSBuLnBhcmVudE5vZGVcblx0d2hpbGUobiAhPSBudWxsICYmIG4ubm9kZU5hbWUgIT0gJ2MnKSBuID0gbi5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5lbnN1cmVfdGV4dF9ub2RlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGwgPSB0aGlzLmJhc2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJlXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSsrKXtcblx0aWYoIShsW2ldLmZpcnN0Q2hpbGQpKSBsW2ldLmFwcGVuZENoaWxkKHRoaXMuYmFzZS5jcmVhdGVUZXh0Tm9kZShcIlwiKSk7XG4gICAgfVxufVxuXG4vKiogXG4gICAgQ2hlY2sgaWYgZG9jdW1lbnQgaXMgZW1wdHlcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcmV0dXJucyB7Ym9vbGVhbn1cbiovXG5HdXBweURvYy5wcm90b3R5cGUuaXNfYmxhbmsgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuYmFzZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZcIikubGVuZ3RoID4gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsID0gdGhpcy5iYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZVwiKTtcbiAgICBpZihsLmxlbmd0aCA9PSAxICYmICghKGxbMF0uZmlyc3RDaGlsZCkgfHwgbFswXS5maXJzdENoaWxkLnRleHRDb250ZW50ID09IFwiXCIpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqIFxuICAgIEdldCB0aGUgZG9jdW1lbnQgYXMgYSBET00gb2JqZWN0XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHJldHVybnMge0VsZW1lbnR9XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmJhc2UuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKiogXG4gICAgR2V0IHRoZSBjb250ZW50IG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZ1xuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEBwYXJhbSB7c3RyaW5nfSB0IC0gVGhlIHJlbmRlcmluZyBtZXRob2QgdG8gdXNlIChcImxhdGV4XCIsIFwidGV4dFwiLCBcImFzdFwiIChmb3Igc3ludGF4IHRyZWUpLCBvciBcInhtbFwiIChmb3IgaW50ZXJuYWwgWE1MIHJlcHJlc2VudGF0aW9uKSlcbiAgICBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5nZXRfY29udGVudCA9IGZ1bmN0aW9uKHQscil7XG4gICAgaWYodCA9PSBcInhtbFwiKSByZXR1cm4gKG5ldyBYTUxTZXJpYWxpemVyKCkpLnNlcmlhbGl6ZVRvU3RyaW5nKHRoaXMuYmFzZSk7XG4gICAgZWxzZSBpZih0ID09IFwiYXN0XCIpIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnN5bnRheF90cmVlKCkpO1xuICAgIGVsc2UgcmV0dXJuIHRoaXMubWFudWFsX3JlbmRlcih0LHRoaXMucm9vdCgpLHIpO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUuc3ludGF4X3RyZWUgPSBmdW5jdGlvbihuKXtcbiAgICBuID0gbiB8fCB0aGlzLnJvb3QoKVxuICAgIGlmKG4ubm9kZU5hbWUgPT0gXCJlXCIpe1xuXHRjb25zb2xlLmxvZyhcIlNob3VsZCBuZXZlciBoYXBwZW5cIik7XG5cdC8vYW5zID0gbi5maXJzdENoaWxkLnRleHRDb250ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJmXCIpe1xuXHR2YXIgYW5zID0ge1wiYXJnc1wiOltdLCBcImt3YXJnc1wiOnt9fTtcblx0YW5zWyd2YWx1ZSddID0gbi5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHRhbnNbJ3R5cGUnXSA9IFwiZnVuY3Rpb25cIjtcblx0aWYobi5oYXNBdHRyaWJ1dGUoXCJhc3RfdmFsdWVcIikpIGFuc1sndmFsdWUnXSA9IG4uZ2V0QXR0cmlidXRlKFwiYXN0X3ZhbHVlXCIpO1xuXHRpZihuLmhhc0F0dHJpYnV0ZShcImFzdF90eXBlXCIpKSBhbnNbJ3R5cGUnXSA9IG4uZ2V0QXR0cmlidXRlKFwiYXN0X3R5cGVcIik7XG5cdGVsc2UgaWYobi5nZXRBdHRyaWJ1dGUoXCJjaGFyXCIpID09IFwieWVzXCIpIGFuc1sndHlwZSddID0gXCJuYW1lXCI7XG5cdFxuXHR2YXIgaXRlcmF0b3IgPSB0aGlzLnhwYXRoX2xpc3QoXCIuLypbbmFtZSgpPSdjJyBvciBuYW1lKCk9J2wnXVwiLCBuKVxuXHRmb3IodmFyIG5uID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKTsgbm4gIT0gbnVsbDsgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpKXtcblx0ICAgIGlmKG5uLmhhc0F0dHJpYnV0ZShcIm5hbWVcIikpIGFucy5rd2FyZ3Nbbm4uZ2V0QXR0cmlidXRlKFwibmFtZVwiKV0gPSB0aGlzLnN5bnRheF90cmVlKG5uKVxuXHQgICAgZWxzZSBhbnMuYXJncy5wdXNoKHRoaXMuc3ludGF4X3RyZWUobm4pKVxuXHR9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImxcIil7XG5cdGFucyA9IFtdO1xuXHRmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0ICAgIGFucy5wdXNoKHRoaXMuc3ludGF4X3RyZWUobm4pKTtcblx0fVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJjXCIgfHwgbi5ub2RlTmFtZSA9PSBcIm1cIil7XG5cdHZhciB0b2tlbnMgPSBbXVxuXHRmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0ICAgIGlmKG5uLm5vZGVOYW1lID09IFwiZVwiKXtcblx0XHR0b2tlbnMgPSB0b2tlbnMuY29uY2F0KEd1cHB5RG9jLnRva2VuaXNlKG5uLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQpKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYobm4ubm9kZU5hbWUgPT0gXCJmXCIpe1xuXHRcdHRva2Vucy5wdXNoKHRoaXMuc3ludGF4X3RyZWUobm4pKTtcblx0ICAgIH1cblx0fVxuXHRhbnMgPSBHdXBweURvYy5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUueHBhdGhfbm9kZSA9IGZ1bmN0aW9uKHhwYXRoLCBub2RlKXtcbiAgICBub2RlID0gbm9kZSB8fCB0aGlzLnJvb3QoKVxuICAgIHJldHVybiB0aGlzLmJhc2UuZXZhbHVhdGUoeHBhdGgsIG5vZGUsIG51bGwsIFhQYXRoUmVzdWx0LkZJUlNUX09SREVSRURfTk9ERV9UWVBFLCBudWxsKS5zaW5nbGVOb2RlVmFsdWU7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS54cGF0aF9saXN0ID0gZnVuY3Rpb24oeHBhdGgsIG5vZGUpe1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMucm9vdCgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5ldmFsdWF0ZSh4cGF0aCwgbm9kZSwgbnVsbCwgWFBhdGhSZXN1bHQuT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsIG51bGwpO1xufVxuXG4vKiogXG4gICAgR2V0IHRoZSBuYW1lcyBvZiBzeW1ib2xzIHVzZWQgaW4gdGhpcyBkb2N1bWVudFxuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEBwYXJhbSB7c3RyaW5nW119IFtncm91cHNdIC0gQSBsaXN0IG9mIGdyb3VwcyB5b3Ugd2FudCBzdHJpbmdzIGZvclxuICAgIEByZXR1cm5zIHtzdHJpbmdbXX1cbiovXG5HdXBweURvYy5wcm90b3R5cGUuZ2V0X3N5bWJvbHMgPSBmdW5jdGlvbihncm91cHMpe1xuICAgIHZhciB0eXBlcyA9IHt9O1xuICAgIHZhciBhbnMgPSBbXTtcbiAgICB2YXIgaXRlcmF0b3IgPSBncm91cHMgPyB0aGlzLnhwYXRoX2xpc3QoXCIvL2ZcIikgOiB0aGlzLnhwYXRoX2xpc3QoXCIvL2ZbQGdyb3VwPSdcIitncm91cHNbaV0rXCInXVwiKTtcbiAgICBmb3IodmFyIG5uID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKTsgbm4gIT0gbnVsbDsgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpKVxuXHR0eXBlc1tubi5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpXSA9IHRydWU7XG4gICAgZm9yKHZhciB0IGluIHR5cGVzKVxuXHRhbnMucHVzaCh0KTtcbiAgICByZXR1cm4gYW5zO1xufVxuXG4vKiogXG4gICAgU2V0IHRoZSBjb250ZW50IG9mIHRoZSBkb2N1bWVudFxuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEBwYXJhbSB7c3RyaW5nfSB4bWxfZGF0YSAtIEFuIFhNTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IG9mIHRoZSBkb2N1bWVudFxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5zZXRfY29udGVudCA9IGZ1bmN0aW9uKHhtbF9kYXRhKXtcbiAgICB0aGlzLmJhc2UgPSAobmV3IHdpbmRvdy5ET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKHhtbF9kYXRhLCBcInRleHQveG1sXCIpO1xuICAgIHRoaXMuZW5zdXJlX3RleHRfbm9kZXMoKTtcbn1cblxuR3VwcHlEb2MuYnJhY2tldF94cGF0aCA9IFwiKGNvdW50KC4vKikgIT0gMSBhbmQgbm90IFxcXG5cdFx0ICAgICAgICAgICggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCguL2UpPTIgYW5kIFxcXG5cdFx0XHQgICAgY291bnQoLi9mKT0xIGFuZCBcXFxuXHRcdFx0ICAgIGNvdW50KC4vZVtzdHJpbmctbGVuZ3RoKHRleHQoKSk9MF0pPTIgYW5kIFxcXG5cdFx0XHQgICAgKCBcXFxuXHRcdFx0ICAgICAgKFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50KC4vZi9jKT0xIGFuZFxcXG5cdFx0XHQgICAgICAgIGNvdW50KC4vZi9jW0Bpc19icmFja2V0PSd5ZXMnXSk9MVxcXG5cdFx0XHQgICAgICApXFxcblx0XHRcdCAgICAgIG9yXFxcblx0XHRcdCAgICAgIChcXFxuXHRcdFx0ICAgICAgICBmL0BjPSd5ZXMnIGFuZCBcXFxuXHRcdFx0XHRjb3VudCguL2VbQGN1cnJlbnQ9J3llcyddKT0wIGFuZCBcXFxuXHRcdFx0XHRjb3VudCguL2VbQHRlbXA9J3llcyddKT0wIFxcXG5cdFx0XHQgICAgICApXFxcblx0XHRcdCAgICApXFxcblx0XHRcdCAgKVxcXG5cdFx0XHQpICBcXFxuXHRcdFx0b3JcXFxuXHRcdCAgICAgICAgKFxcXG5cdFx0XHQgIGNvdW50KC4vKikgPSAxIGFuZCBcXFxuXHRcdFx0ICBzdHJpbmctbGVuZ3RoKC4vZS90ZXh0KCkpICE9IDEgYW5kIFxcXG5cdFx0XHQgIG51bWJlciguL2UvdGV4dCgpKSAhPSAuL2UvdGV4dCgpIFxcXG5cdFx0XHQpIFxcXG5cdFx0XHRvciBcXFxuXHRcdCAgICAgICAgKCBcXFxuXHRcdFx0ICBjb3VudCguLyopID0gMSBhbmQgXFxcblx0XHRcdCAgLi9lL0BjdXJyZW50ID0gJ3llcycgXFxcblx0XHRcdCkgXFxcblx0XHRcdG9yIFxcXG5cdFx0ICAgICAgICAoIFxcXG5cdFx0XHQgIGNvdW50KC4vKikgPSAxIGFuZCBcXFxuXHRcdFx0ICAuL2UvQHRlbXAgPSAneWVzJyBcXFxuXHRcdFx0KVwiXG5cbkd1cHB5RG9jLnByb3RvdHlwZS5tYW51YWxfcmVuZGVyID0gZnVuY3Rpb24odCxuLHIpe1xuICAgIHZhciBhbnMgPSBcIlwiO1xuICAgIGlmKG4ubm9kZU5hbWUgPT0gXCJlXCIpe1xuXHRpZih0ID09IFwibGF0ZXhcIiAmJiByKXtcblx0ICAgIGFucyA9IG4uZ2V0QXR0cmlidXRlKFwicmVuZGVyXCIpO1xuXHR9XG5cdGVsc2UgaWYodCA9PSBcInRleHRcIil7XG5cdCAgICBhbnMgPSBuLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQ7XG5cdCAgICBpZihuLnByZXZpb3VzU2libGluZyAmJiBuLm5leHRTaWJsaW5nICYmIGFucyA9PSBcIlwiKVxuXHRcdGFucyA9IFwiICogXCI7XG5cdCAgICBlbHNlIHtcblx0XHRhbnMgPSBhbnMucmVwbGFjZSgvKC4pKFteYS16QS1aMC05Ll0pKC4pL2csXCIkMSAkMiAkM1wiKTtcblx0XHRhbnMgPSBhbnMucmVwbGFjZSgvKFthLXpBLVpdKSg/PVxcLikvZyxcIiQxICogXCIpO1xuXHRcdGFucyA9IGFucy5yZXBsYWNlKC8oXFwuKSg/PVthLXpBLVpdKS9nLFwiJDEgKiBcIik7XG5cdFx0YW5zID0gYW5zLnJlcGxhY2UoLyhbYS16QS1aXSkoPz1bYS16QS1aMC05XSkvZyxcIiQxICogXCIpO1xuXHRcdGFucyA9IGFucy5yZXBsYWNlKC8oW2EtekEtWjAtOV0pKD89W2EtekEtWl0pL2csXCIkMSAqIFwiKTtcblx0XHRpZihuLnByZXZpb3VzU2libGluZyAmJiBuLnByZXZpb3VzU2libGluZy5nZXRBdHRyaWJ1dGUoXCJncm91cFwiKSAhPSBcIm9wZXJhdGlvbnNcIikgYW5zID0gYW5zLnJlcGxhY2UoL14oW2EtekEtWjAtOV0pL2csXCIgKiAkMVwiKTtcblx0XHRpZihuLm5leHRTaWJsaW5nICYmIG4ubmV4dFNpYmxpbmcuZ2V0QXR0cmlidXRlKFwiZ3JvdXBcIikgIT0gXCJvcGVyYXRpb25zXCIpIGFucyA9IGFucy5yZXBsYWNlKC8oW2EtekEtWjAtOV0pJC9nLFwiJDEgKiBcIik7XG5cdFx0YW5zID0gXCIgXCIrYW5zK1wiIFwiO1xuXHQgICAgfVxuXHR9XG5cdGVsc2V7XG5cdCAgICBhbnMgPSBuLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQ7XG5cdH1cbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwiZlwiKXtcblx0dmFyIHJlYWxfdHlwZSA9ICh0ID09IFwibGF0ZXhcIiAmJiB0aGlzLmlzX3NtYWxsKG4pKSA/IFwic21hbGxfbGF0ZXhcIiA6IHQ7XG5cdHZhciBubiA9IHRoaXMueHBhdGhfbm9kZShcIi4vYltAcD0nXCIrcmVhbF90eXBlK1wiJ11cIiwgbikgfHwgdGhpcy54cGF0aF9ub2RlKFwiLi9iW0BwPSdcIit0K1wiJ11cIiwgbik7XG5cdGlmKG5uKSBhbnMgPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwiYlwiKXtcblx0dmFyIGNzID0gW11cblx0dmFyIGkgPSAxO1xuXHR2YXIgcGFyID0gbi5wYXJlbnROb2RlO1xuXHRmb3IodmFyIG5uID0gcGFyLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpXG5cdCAgICBpZihubi5ub2RlTmFtZSA9PSBcImNcIiB8fCBubi5ub2RlTmFtZSA9PSBcImxcIikgY3NbaSsrXSA9IHRoaXMubWFudWFsX3JlbmRlcih0LG5uLHIpO1xuXHRmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0ICAgIGlmKG5uLm5vZGVUeXBlID09IDMpIGFucyArPSBubi50ZXh0Q29udGVudDtcblx0ICAgIGVsc2UgaWYobm4ubm9kZVR5cGUgPT0gMSl7XG5cdFx0aWYobm4uaGFzQXR0cmlidXRlKFwiZFwiKSl7XG5cdFx0ICAgIHZhciBkaW0gPSBwYXJzZUludChubi5nZXRBdHRyaWJ1dGUoXCJkXCIpKTtcblx0XHQgICAgdmFyIGpvaW5lciA9IGZ1bmN0aW9uKGQsbCl7XG5cdFx0XHRpZihkID4gMSkgZm9yKHZhciBrID0gMDsgayA8IGwubGVuZ3RoOyBrKyspIGxba10gPSBqb2luZXIoZC0xLGxba10pO1xuXHRcdFx0cmV0dXJuIGwuam9pbihubi5nZXRBdHRyaWJ1dGUoJ3NlcCcrKGQtMSkpKTtcblx0XHQgICAgfVxuXHRcdCAgICBhbnMgKz0gam9pbmVyKGRpbSxjc1twYXJzZUludChubi5nZXRBdHRyaWJ1dGUoXCJyZWZcIikpXSk7XG5cdFx0fVxuXHRcdGVsc2UgYW5zICs9IGNzW3BhcnNlSW50KG5uLmdldEF0dHJpYnV0ZShcInJlZlwiKSldO1xuXHQgICAgfVxuXHR9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImxcIil7XG5cdGFucyA9IFtdO1xuXHR2YXIgaSA9IDA7XG5cdGZvcih2YXIgbm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuXHQgICAgYW5zW2krK10gPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcblx0fVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJjXCIgfHwgbi5ub2RlTmFtZSA9PSBcIm1cIil7XG5cdGZvcih2YXIgbm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpXG5cdCAgICBhbnMgKz0gdGhpcy5tYW51YWxfcmVuZGVyKHQsbm4scik7XG5cdGlmKHQgPT0gXCJsYXRleFwiICYmXG4gICAgICAgICAgIG4uZ2V0QXR0cmlidXRlKFwiYnJhY2tldFwiKSA9PSBcInllc1wiICYmXG5cdCAgIHRoaXMuYmFzZS5ldmFsdWF0ZShHdXBweURvYy5icmFja2V0X3hwYXRoLCBuLCBudWxsLFxuXHRcdFx0IFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSwgbnVsbCkuYm9vbGVhblZhbHVlKXsgXG5cdCAgICBhbnMgPSBcIlxcXFxsZWZ0KFwiK2FucytcIlxcXFxyaWdodClcIjtcblx0fVxuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUucGF0aF90byA9IGZ1bmN0aW9uKG4pe1xuICAgIHZhciBuYW1lID0gbi5ub2RlTmFtZTtcbiAgICBpZihuYW1lID09IFwibVwiKSByZXR1cm4gXCJndXBweV9sb2NfbVwiO1xuICAgIHZhciBucyA9IDA7XG4gICAgZm9yKHZhciBubiA9IG47IG5uICE9IG51bGw7IG5uID0gbm4ucHJldmlvdXNTaWJsaW5nKSBpZihubi5ub2RlVHlwZSA9PSAxICYmIG5uLm5vZGVOYW1lID09IG5hbWUpIG5zKys7XG4gICAgcmV0dXJuIHRoaXMucGF0aF90byhuLnBhcmVudE5vZGUpK1wiX1wiK25hbWUrXCJcIitucztcbn1cblxuR3VwcHlEb2MudG9rZW5pc2UgPSBmdW5jdGlvbihzKXtcbiAgICB2YXIgdG9rZW5zID0gW1xuXHR7XCJ0eXBlXCI6XCJudW1iZXJcIiwgXCJyZVwiOlwiXlswLTldKyhcXFxcLlswLTldKyk/XCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gTnVtYmVyKG0pfX0sXG5cdHtcInR5cGVcIjpcIm9wZXJhdG9yXCIsIFwicmVcIjpcIl5bXFwtKyovIV1cIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG5cdHtcInR5cGVcIjpcIm5hbWVcIiwgXCJyZVwiOlwiXlthLXpBLVpdXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuXHR7XCJ0eXBlXCI6XCJzcGFjZVwiLCBcInJlXCI6XCJeXFxcXHMrXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgIF07XG4gICAgdmFyIGFucyA9IFtdO1xuICAgIHdoaWxlKHMubGVuZ3RoID4gMCl7XG5cdHZhciBvayA9IGZhbHNlO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKXtcblx0ICAgIHZhciB0ID0gdG9rZW5zW2ldO1xuXHQgICAgcmUgPSBSZWdFeHAodC5yZSk7XG5cdCAgICB2YXIgbSA9IHJlLmV4ZWMocyk7XG5cdCAgICBpZihtKXtcblx0XHRtID0gbVswXTtcblx0XHRzID0gcy5zdWJzdHJpbmcobS5sZW5ndGgpO1xuXHRcdG9rID0gdHJ1ZTtcblx0XHRpZih0LnR5cGUgIT0gXCJzcGFjZVwiKSBhbnMucHVzaCh7XCJ0eXBlXCI6dC50eXBlLCBcInZhbHVlXCI6IHQudmFsdWUobSl9KVxuXHRcdGJyZWFrO1xuXHQgICAgfVxuXHR9XG5cdGlmKCFvayl7XG5cdCAgICBjb25zb2xlLmxvZyhcIlRva2VuaXNpbmcgZXJyb3JcIik7XG5cdCAgICByZXR1cm4gW107XG5cdH1cbiAgICB9XG4gICAgcmV0dXJuIGFucztcbn1cblxuR3VwcHlEb2MucGFyc2UgPSBmdW5jdGlvbih0b2tlbnMpe1xuICAgIHZhciBzeW1ib2xfdGFibGUgPSB7fTtcblxuICAgIHZhciBvcmlnaW5hbF9zeW1ib2wgPSB7XG5cdG51ZDogZnVuY3Rpb24gKCkgeyB0aHJvdyBFcnJvcihcIlVuZGVmaW5lZFwiKTsgfSxcblx0bGVkOiBmdW5jdGlvbiAobGVmdCkgeyB0aHJvdyBFcnJvcihcIk1pc3Npbmcgb3BlcmF0b3JcIik7IH1cbiAgICB9O1xuXG4gICAgdmFyIG11bCA9IGZ1bmN0aW9uKGxlZnQpeyByZXR1cm4gW1wiKlwiLCBbbGVmdCwgdGhpcy5udWQoKV1dOyB9O1xuICAgIFxuICAgIHZhciBzeW1ib2wgPSBmdW5jdGlvbiAoaWQsIGJwKSB7XG5cdHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcblx0YnAgPSBicCB8fCAwO1xuXHRpZiAocykge1xuICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG5cdFx0cy5sYnAgPSBicDtcbiAgICAgICAgICAgIH1cblx0fSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsX3N5bWJvbCk7XG4gICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuXHR9XG5cdHJldHVybiBzO1xuICAgIH07XG5cbiAgICBzeW1ib2woXCIoZW5kKVwiKTtcblxuICAgIHMgPSBzeW1ib2woXCIoYmxhbmspXCIsIDYwKTtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbXCJibGFua1wiXTt9O1xuICAgIFxuICAgIHMgPSBzeW1ib2woXCIoZnVuY3Rpb24pXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy5hcmdzIHx8IFtdLCB0aGlzLmt3YXJncyB8fCB7fV07fTtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKGxpdGVyYWwpXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbXCJ2YWxcIiwgW3RoaXMudmFsdWVdXSB9O1xuXG4gICAgcyA9IHN5bWJvbChcIih2YXIpXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbXCJ2YXJcIiwgW3RoaXMudmFsdWVdXSB9O1xuXG4gICAgdmFyIHRva2VuO1xuICAgIHZhciB0b2tlbl9uciA9IDA7XG5cbiAgICB2YXIgYWR2YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuXHR2YXIgYSwgbywgdCwgdjtcblx0aWYgKGlkICYmIHRva2VuLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZCArIFwiJ1wiKTtcblx0fVxuXHRpZiAodG9rZW5fbnIgPj0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBzeW1ib2xfdGFibGVbXCIoZW5kKVwiXTtcbiAgICAgICAgICAgIHJldHVybjtcblx0fVxuXHR0ID0gdG9rZW5zW3Rva2VuX25yXTtcblx0dG9rZW5fbnIgKz0gMTtcblx0diA9IHQudmFsdWU7XG5cdHZhciBhcmdzID0gbnVsbDtcblx0dmFyIGt3YXJncyA9IG51bGw7XG5cdGEgPSB0LnR5cGU7XG5cdGlmIChhID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIih2YXIpXCJdO1xuXHR9IGVsc2UgaWYgKGEgPT09IFwib3BlcmF0b3JcIikge1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVt2XTtcbiAgICAgICAgICAgIGlmICghbykge1xuXHRcdHQuZXJyb3IoXCJVbmtub3duIG9wZXJhdG9yLlwiKTtcbiAgICAgICAgICAgIH1cblx0fSBlbHNlIGlmIChhID09PSAgXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYSA9IFwibGl0ZXJhbFwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcblx0fSBlbHNlIGlmIChhID09PSAgXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhID0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihmdW5jdGlvbilcIl07XG5cdCAgICBhcmdzID0gdC5hcmdzO1xuXHQgICAga3dhcmdzID0gdC5rd2FyZ3M7XG5cdH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW5cIix0KTtcblx0fVxuXHR0b2tlbiA9IE9iamVjdC5jcmVhdGUobyk7XG5cdHRva2VuLnR5cGUgPSBhO1xuXHR0b2tlbi52YWx1ZSA9IHY7XG5cdGlmKGFyZ3MpIHRva2VuLmFyZ3MgPSBhcmdzO1xuXHRpZihrd2FyZ3MpIHRva2VuLmt3YXJncyA9IGt3YXJncztcblx0cmV0dXJuIHRva2VuO1xuICAgIH07XG5cblxuICAgIHZhciBleHByZXNzaW9uID0gZnVuY3Rpb24gKHJicCkge1xuXHR2YXIgbGVmdDtcblx0dmFyIHQgPSB0b2tlbjtcblx0YWR2YW5jZSgpO1xuXHRsZWZ0ID0gdC5udWQoKTtcblx0d2hpbGUgKHJicCA8IHRva2VuLmxicCkge1xuICAgICAgICAgICAgdCA9IHRva2VuO1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgbGVmdCA9IHQubGVkKGxlZnQpO1xuXHR9XG5cdHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgaW5maXggPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcblx0dmFyIHMgPSBzeW1ib2woaWQsIGJwKTtcblx0cy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2xlZnQsIGV4cHJlc3Npb24oYnApXV07XG5cdH07XG5cdHJldHVybiBzO1xuICAgIH1cblxuICAgIGluZml4KFwiK1wiLCA1MCk7XG4gICAgaW5maXgoXCItXCIsIDUwKTtcbiAgICBpbmZpeChcIipcIiwgNjApO1xuICAgIGluZml4KFwiL1wiLCA2MCk7XG4gICAgdmFyIHByZWZpeCA9IGZ1bmN0aW9uIChpZCwgbnVkKSB7XG5cdHZhciBzID0gc3ltYm9sKGlkKTtcblx0cy5udWQgPSBudWQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnZhbHVlLCBbZXhwcmVzc2lvbig3MCldXTtcblx0fTtcblx0cmV0dXJuIHM7XG4gICAgfVxuXG4gICAgcHJlZml4KFwiLVwiKTtcbiAgICBwcmVmaXgoXCIhXCIpO1xuICAgIHByZWZpeChcInR5cGVvZlwiKTtcblxuICAgIGlmKHRva2Vucy5sZW5ndGggPT0gMCkgcmV0dXJuIFtcImJsYW5rXCJdO1xuICAgIFxuICAgIGFkdmFuY2UoKTtcbiAgICBcbiAgICByZXR1cm4gZXhwcmVzc2lvbigxMCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VwcHlEb2M7XG4iXX0=
