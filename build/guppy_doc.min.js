(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GuppyDoc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var GuppyAST = {};

GuppyAST.tokenise = function(s, tokens){
    var ans = [];
    while(s.length > 0){
        var ok = false;
        for(var i = 0; i < tokens.length; i++){
            var t = tokens[i];
            var re = RegExp(t.re);
            var m = re.exec(s);
            if(m){
                m = m[0];
                s = s.substring(m.length);
                ok = true;
                if(t.type != "space") ans.push({"type":t.type, "value": t.value(m)})
                break;
            }
        }
        if(!ok){
            return [];
        }
    }
    return ans;
}

GuppyAST.tokenise_e = function(s){
    return GuppyAST.tokenise(s, [
        {"type":"number", "re":"^[0-9.]+", "value":function(m){
            if(isNaN(Number(m))) throw "Invalid number: "+m;
            return Number(m);
        }},
        {"type":"operator", "re":"^(<=|>=|!=|>|<|=)", "value":function(m){return m}},
        {"type":"operator", "re":"^[-+*/!]", "value":function(m){return m}},
        {"type":"name", "re":"^[a-zA-Z]", "value":function(m){return m}},
        {"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ]);
}

GuppyAST.to_eqlist = function(ast){
    var comparators = ["=","!=","<=",">=","<",">"];
    if(ast[1].length == 0 || comparators.indexOf(ast[1][0][0]) < 0) return [ast];
    return GuppyAST.to_eqlist(ast[1][0]).concat([[ast[0],[ast[1][0][1][1],ast[1][1]]]]);
}

GuppyAST.to_text = function(ast){
    var functions = {};
    functions["bracket"] = function(args){return "("+args[0]+")";};
    functions["="] = function(args){return args[0]+" = "+args[1];};
    functions["!="] = function(args){return args[0]+" != "+args[1];};
    functions["<="] = function(args){return args[0]+" <= "+args[1];};
    functions[">="] = function(args){return args[0]+" >= "+args[1];};
    functions["<"] = function(args){return args[0]+" < "+args[1];};
    functions[">"] = function(args){return args[0]+" > "+args[1];};
    functions["*"] = function(args){return "("+args[0]+" * "+args[1]+")";};
    functions["+"] = function(args){return "("+args[0]+" + "+args[1]+")";};
    functions["/"] = function(args){return "("+args[0]+" / "+args[1]+")";};
    functions["fraction"] = function(args){return "("+args[0]+" / "+args[1]+")";};
    functions["-"] = function(args){return args.length == 1 ? "-"+args[0] : "("+args[0]+" - "+args[1]+")";};
    functions["val"] = function(args){return args[0]+"";};
    functions["var"] = function(args){return args[0];};
    functions["subscript"] = function(args){return "("+args[0]+"_"+args[1]+")";};
    functions["exponential"] = function(args){return "("+args[0]+"^"+args[1]+")";};
    functions["factorial"] = function(args){return "("+args[0]+")!";};
    functions["_default"] = function(name, args){return name + "(" + args.join(",") + ")";};
    return GuppyAST.eval(ast, functions);
}

GuppyAST.to_xml = function(ast, symbols, symbol_to_node){
    var prepend_str = function(doc, str){
        doc.documentElement.firstChild.textContent = str + doc.documentElement.firstChild.textContent;
    }
    var append_str = function(doc, str){
        doc.documentElement.lastChild.textContent += str;
    }
    var append_doc = function(doc, doc2){
        var n = doc.documentElement.lastChild;
        var nn = doc2.documentElement.firstChild
        n.firstChild.textContent += nn.firstChild.textContent;
        for(nn = nn.nextSibling; nn; nn = nn.nextSibling){
            n.parentNode.insertBefore(nn.cloneNode(true),null); 
        }
    }
    var ensure_text_nodes = function(base){
        var l = base.getElementsByTagName("e");
        for(var i = 0; i < l.length; i++){
            if(!(l[i].firstChild)) l[i].appendChild(base.createTextNode(""));
        }
    }
    var get_symbol = function(name, symbols){
        for(var s in symbols){
            if(symbols[s].attrs.type == name) return symbols[s];
        }
    }
    var get_content_array = function(args){
        var content = {};
        for(var i = 0; i < args.length; i++){
            content[i] = [];
            if(args[i].documentElement.nodeName == "l") content[i].push(args[i].documentElement);
            else for(var nn = args[i].documentElement.firstChild; nn; nn = nn.nextSibling) content[i].push(nn);
        }
        return content;
    }
    var binop_low = function(args, op, parent){
        var d = args[0].cloneNode(true);
        append_str(d, op);
        append_doc(d, args[1].cloneNode(true));
        if(parent && (parent[0] == "*" || (parent[0] == "-" && parent[1].length == 1)))
            return make_sym("bracket", [d]);
        else
            return d;
    }
    var binop_high = function(args, op){
        var d = args[0].cloneNode(true);
        append_doc(d, make_sym(op,[]));
        append_doc(d, args[1].cloneNode(true));
        return d;
    }
    var make_sym = function(name, args){
        var sym = get_symbol(name, symbols);
        if(!sym) throw "Unrecognised symbol: "+name;
        var base = (new window.DOMParser()).parseFromString("<c><e></e><e></e></c>", "text/xml");
        ensure_text_nodes(base);
        var e0 = base.documentElement.firstChild;
        var content = get_content_array(args);
        var f = symbol_to_node(sym, content, base)['f'];
        e0.parentNode.insertBefore(f,e0.nextSibling);
        ensure_text_nodes(base);
        return base;
    }
    var functions = {};

    var ops = ["*","<",">","=","<=",">=","!="];
    for(var i = 0; i < ops.length; i++){
        functions[ops[i]] = function(o){ return function(args){ return binop_high(args, o); }}(ops[i]);
    }
    functions["/"] = function(args){
        return make_sym("fraction",args);
    };
    functions["+"] = function(args, parent){ return binop_low(args, "+", parent); };
    functions["-"] = function(args, parent) {
        if(args.length == 1) {
            var d = args[0].cloneNode(true);
            prepend_str(d, "-");
            return d;
        }
        else {
            return binop_low(args, "-", parent);
        }
    }
    functions["val"] = function(args){ return (new window.DOMParser()).parseFromString("<c><e>" + args[0] + "</e></c>", "text/xml");};
    functions["var"] = function(args){
        if(args[0].length == 1) return (new window.DOMParser()).parseFromString("<c><e>" + args[0] + "</e></c>", "text/xml");
        else return make_sym(args[0], {});
    };
    functions["list"] = function(args){
        var base = (new window.DOMParser()).parseFromString("<l></l>", "text/xml");
        for(var i = 0; i < args.length; i++){
            base.documentElement.appendChild(args[i].documentElement.cloneNode(true));
        }
        base.documentElement.firstChild.setAttribute("s",String(args.length))
        return base;
    };
    // var comparators = {"<":"less",">":"greater","=":"eq","!=":"neq",">=":"geq","<=":"leq"};
    // for(var c in comparators){
    //     functions[c] = function(args){
    //         return make_sym(comparators[c], args);
    //     }
    // }
    functions["_default"] = function(name, args){
        return make_sym(name, args);
    }
    var ans = GuppyAST.eval(ast, functions);
    var new_base = (new window.DOMParser()).parseFromString("<m></m>", "text/xml");
    for(var nn = ans.documentElement.firstChild; nn; nn = nn.nextSibling){
        new_base.documentElement.insertBefore(nn.cloneNode(true),null);
    }
    return new_base;

}

GuppyAST.get_nodes = function(ast, name){
    if(ast.length < 2) return [];
    var ans = [];
    if(ast[0] == name) ans.push(ast[1]);
    if(ast[0] == "var" || ast[0] == "val") return ans;
    for(var i = 0; i < ast[1].length; i++) ans = ans.concat(GuppyAST.get_nodes(ast[1][i], name));
    return ans;
}

GuppyAST.get_vars = function(ast){
    var vars = {};
    var ans = [];
    var l = GuppyAST.get_nodes(ast, "var");
    for(var i = 0; i < l.length; i++) vars[l[i][0]] = true;
    for(var x in vars) ans.push(x);
    return ans;
}

GuppyAST.to_function = function(ast, functions){
    functions = functions || {}
    var defaults = {}
    defaults["*"] = function(args){return function(vars){return args[0](vars)*args[1](vars)};};
    defaults["+"] = function(args){return function(vars){return args[0](vars)+args[1](vars)};};
    defaults["fraction"] = function(args){return function(vars){return args[0](vars)/args[1](vars)};};
    defaults["/"] = function(args){return function(vars){return args[0](vars)/args[1](vars)};};
    defaults["-"] = function(args){return args.length == 1 ? function(vars){return -args[0](vars)} : function(vars){return args[0](vars)-args[1](vars)};};
    defaults["val"] = function(args){return function(){ return args[0]; };};
    defaults["var"] = function(args){return function(vars){ if(args[0] == "pi") return Math.PI; if(args[0] == "e") return Math.E; return vars[args[0]]; };};
    defaults["exponential"] = function(args){return function(vars){return Math.pow(args[0](vars),args[1](vars))};};
    defaults["square_root"] = function(args){return function(vars){return Math.sqrt(args[0](vars))};};
    defaults["sin"] = function(args){return function(vars){return Math.sin(args[0](vars))};};
    defaults["cos"] = function(args){return function(vars){return Math.cos(args[0](vars))};};
    defaults["tan"] = function(args){return function(vars){return Math.tan(args[0](vars))};};
    defaults["log"] = function(args){return function(vars){return Math.log(args[0](vars))};};
    for(var n in defaults) if(!functions[n]) functions[n] = defaults[n];
    return {"function":GuppyAST.eval(ast, functions),"vars":GuppyAST.get_vars(ast)};
}

GuppyAST.eval = function(ast, functions, parent){
    ans = null;
    if(!functions["_default"]) functions["_default"] = function(name, args){ throw "Function not implemented: " + name + "(" + args + ")";}
    
    var args = []
    for(var i = 0; i < ast[1].length; i++){
        if(Object.prototype.toString.call(ast[1][i]) === '[object Array]'){
            args.push(GuppyAST.eval(ast[1][i], functions, ast));
        }
        else{
            args.push(ast[1][i]);
        }
    }
    //console.log("Fn",ast[0],functions[ast[0]]);
    var ans = null;
    if(functions[ast[0]]) ans = functions[ast[0]](args, parent);
    else if(functions["_default"]) ans = functions["_default"](ast[0], args, parent);
    
    //console.log("EVAL",JSON.stringify(ast),'=',ans);
    return ans
}

GuppyAST.parse_e = function(tokens){
    var symbol_table = {};

    var original_symbol = {
        nud: function () { throw Error("Undefined"); },
        led: function () { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
        var s = symbol_table[id];
        bp = bp || 0;
        if (s) {
            if (bp >= s.lbp) {
                s.lbp = bp;
            }
        } else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
        }
        return s;
    };

    symbol("(end)");
    var s = null;
    
    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(function)", 60);
    s.led = mul;
    //s.nud = function(){ return [this.value, this.args || [], this.kwargs || {}];};
    s.nud = function(){ return [this.value, this.args || []];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    s = symbol("(pass)", 60);
    s.led = mul;
    s.nud = function(){ return this.args[0] };
    
    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){ return ["var", [this.value]] };

    var token;
    var token_nr = 0;

    var advance = function (id) {
        var a, o, t, v;
        if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
        }
        if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
        }
        t = tokens[token_nr];
        token_nr += 1;
        v = t.value;
        var args = null;
        var kwargs = null;
        a = t.type;
        if (a === "name") {
            o = symbol_table["(var)"];
        } else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
                throw "Unknown operator";
            }
        } else if (a ===  "pass") {
            a = "pass";
            o = symbol_table["(pass)"];
            args = t.args;
        } else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
        } else if (a ===  "function") {
            a = "function";
            o = symbol_table["(function)"];
            args = t.args;
            kwargs = t.kwargs;
        } else {
            throw Error("Unexpected token",t);
        }
        token = Object.create(o);
        token.type = a;
        token.value = v;
        if(args) token.args = args;
        if(kwargs) token.kwargs = kwargs;
        return token;
    };


    var expression = function (rbp) {
        var left;
        var t = token;
        advance();
        left = t.nud();
        while (rbp < token.lbp) {
            t = token;
            advance();
            left = t.led(left);
        }
        return left;
    };

    var infix = function (id, bp, led) {
        var s = symbol(id, bp);
        s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
        };
        return s;
    }

    
    infix("=", 40);
    infix("!=", 40);
    infix("<", 40);
    infix(">", 40);
    infix("<=", 40);
    infix(">=", 40);

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    var prefix = function (id, nud) {
        var s = symbol(id);
        s.nud = nud || function () {
            return [this.value, [expression(70)]];
        };
        return s;
    }

    prefix("-");
    prefix("!");
    prefix("typeof");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}



GuppyAST.tokenise_text = function(s){
    return GuppyAST.tokenise(s, [
        {"type":"number", "re":"^[0-9.]+", "value":function(m){return Number(m)}},
        {"type":"operator", "re":"^(!=|>=|<=)", "value":function(m){return m;}},
        {"type":"operator", "re":"^[-+*/,!()=<>_^]", "value":function(m){return m}},
        {"type":"name", "re":"^[a-zA-Z_]*[a-zA-Z]", "value":function(m){return m}},
        {"type":"comma", "re":"^,", "value":function(m){return m}},
        {"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ]);
}

GuppyAST.parse_text = function(tokens){
    var symbol_table = {};

    var original_symbol = {
        nud: function () { throw Error("Undefined"); },
        led: function () { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
        var s = symbol_table[id];
        bp = bp || 0;
        if (s) {
            if (bp >= s.lbp) {
                s.lbp = bp;
            }
        } else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
        }
        return s;
    };

    symbol("(end)");
    var s = null;
    
    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    var get_args = function(){
        var args = [];
        advance()
        if(token.id !== ")"){
            while(true){
                args.push(expression(0));
                if (token.id !== ",") {
                    break;
                }
                advance(",");
            }
        }
        advance(")");
        return args;
    }
    
    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){
        if(token.id == "("){
            return [this.value, get_args()];
        }
        else{
            return ["var", [this.value]]
        }
    };
    
    var token;
    var token_nr = 0;

    var advance = function (id) {
        var a, o, t, v;
        if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
        }
        if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
        }
        t = tokens[token_nr];
        token_nr += 1;
        v = t.value;
        var args = null;
        a = t.type;
        if (a === "name") {
            o = symbol_table["(var)"];
        } else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
                throw Error("Unknown operator.");
            }
        } else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
        } else {
            throw Error("Unexpected token",t);
        }
        token = Object.create(o);
        token.type = a;
        token.value = v;
        if(args) token.args = args;
        //console.log("ADVD",JSON.stringify(token));
        return token;
    };


    var expression = function (rbp) {
        var left;
        var t = token;
        //console.log("T1",JSON.stringify(token));
        advance();
        //console.log("T2",JSON.stringify(token));
        left = t.nud();
        while (rbp < token.lbp) {
            t = token;
            advance();
            //console.log("RB",JSON.stringify(token));
            left = t.led(left);
        }
        //console.log("POW", rbp, token.id, token.lbp);
        return left;
    };

    var infix = function (id, bp, led) {
        var s = symbol(id, bp);
        s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
        };
        return s;
    }

    infix("=", 40);
    infix("!=", 40);
    infix("<", 40);
    infix(">", 40);
    infix("<=", 40);
    infix(">=", 40);

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    
    infix("!", 70, function(left){
        return ["factorial", [left]];
    });
    
    infix("^", 70, function(left){
        return ["exponential", [left, expression(70)]];
    });
    
    infix("_", 70, function(left){
        return ["subscript", [left, expression(70)]];
    });
    
    infix("(", 80, mul);

    symbol("(").nud = function(){
        var ans = expression(0);
        advance(")");
        return ans;
    }
    symbol(")");
    symbol(",");
    
    var prefix = function (id, nud) {
        var s = symbol(id);
        s.nud = nud || function () {
            return [this.value, [expression(70)]];
        };
        return s;
    }

    prefix("-");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}

module.exports = GuppyAST;

},{}],2:[function(require,module,exports){
var GuppyAST = require('./guppy_ast.js');
var GuppySymbols = require('./guppy_symbols.js');

/**
   @class
   @classdesc A class representing a Guppy document
   @param {string} [doc=<m><e></e></m>] - An XML string representing the document
   @constructor 
 */
var GuppyDoc = function(doc){
    doc = doc || "<m><e></e></m>";
    this.set_content(doc);
}

GuppyDoc.prototype.is_small = function(nn){
    var n = nn.parentNode;
    while(n != null && n.nodeName != 'm'){
        if(n.getAttribute("small") == "yes") return true;
        n = n.parentNode
        while(n != null && n.nodeName != 'c') n = n.parentNode;
    }
    return false;
}

GuppyDoc.prototype.ensure_text_nodes = function(){
    var l = this.base.getElementsByTagName("e");
    for(var i = 0; i < l.length; i++){
        if(!(l[i].firstChild)) l[i].appendChild(this.base.createTextNode(""));
    }
}

/** 
    Check if document is empty
    @memberof GuppyDoc
    @returns {boolean}
*/
GuppyDoc.prototype.is_blank = function(){
    if(this.base.getElementsByTagName("f").length > 0) return false;
    var l = this.base.getElementsByTagName("e");
    if(l.length == 1 && (!(l[0].firstChild) || l[0].firstChild.textContent == "")) return true;
    return false;
}


/** 
    Get the document as a DOM object
    @memberof GuppyDoc
    @returns {Element}
*/
GuppyDoc.prototype.root = function(){
    return this.base.documentElement;
}

/** 
    Get the content of the document as a string
    @memberof GuppyDoc
    @param {string} t - The rendering method to use ("latex", "text", "ast" (for syntax tree), or "xml" (for internal XML representation))
    @returns {string}
*/
GuppyDoc.prototype.get_content = function(t,r){
    if(t == "xml") return (new XMLSerializer()).serializeToString(this.base);
    else if(t == "ast") return JSON.stringify(this.syntax_tree());
    else if(t == "text") return GuppyAST.to_text(this.syntax_tree());
    else if(t == "function") return GuppyAST.to_function(this.syntax_tree());
    else if(t == "eqns") return JSON.stringify(GuppyAST.to_eqlist(this.syntax_tree()));
    else return this.manual_render(t,this.root(),r);
}

GuppyDoc.prototype.evaluate = function(evaluators){
    return GuppyAST.eval(this.syntax_tree(), evaluators);
}

GuppyDoc.prototype.import_text = function(text, syms, s2n){
    var tokens = GuppyAST.tokenise_text(text);
    var ast = GuppyAST.parse_text(tokens);
    this.import_ast(ast, syms, s2n);
}

GuppyDoc.prototype.import_ast = function(ast, syms, s2n){
    syms = syms || GuppySymbols.symbols;
    s2n = s2n || GuppySymbols.symbol_to_node;
    var doc = GuppyAST.to_xml(ast, syms, s2n);
    this.base = doc;
    this.ensure_text_nodes();
}

GuppyDoc.prototype.syntax_tree = function(n){
    n = n || this.root()
    if(n.nodeName == "f"){
        var ans = {"args":[], "kwargs":{}};
        ans['value'] = n.getAttribute("type");
        ans['type'] = "function";
        if(n.hasAttribute("ast_value")) ans['value'] = n.getAttribute("ast_value");
        if(n.hasAttribute("ast_type")) ans['type'] = n.getAttribute("ast_type");
        else if(n.getAttribute("char") == "yes") ans['type'] = "name";
        
        var iterator = this.xpath_list("./*[name()='c' or name()='l']", n)
        for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext()){
            //if(nn.hasAttribute("name")) ans.kwargs[nn.getAttribute("name")] = this.syntax_tree(nn)
            //else ans.args.push(this.syntax_tree(nn))
            ans.args.push(this.syntax_tree(nn))
        }
        //console.log("F",JSON.stringify(ans))
    }
    else if(n.nodeName == "l"){
        ans = [];
        for(nn = n.firstChild; nn != null; nn = nn.nextSibling){
        ans.push(this.syntax_tree(nn));
        }
        ans = ["list",ans];
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
        if(n.hasAttribute("mode") && n.getAttribute("mode") == "text"){
            ans = n.firstChild.firstChild.textContent;
        }
        else{
            var tokens = []
            for(nn = n.firstChild; nn != null; nn = nn.nextSibling){
                if(nn.nodeName == "e"){
                    tokens = tokens.concat(GuppyAST.tokenise_e(nn.firstChild.textContent));
                }
                else if(nn.nodeName == "f"){
                    tokens.push(this.syntax_tree(nn));
                }
            }
            //console.log("TOK",tokens);
            ans = GuppyAST.parse_e(tokens);
        }
    }
    return ans;
}

GuppyDoc.prototype.xpath_node = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

GuppyDoc.prototype.xpath_list = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
}

/** 
    Get the names of symbols used in this document
    @memberof GuppyDoc
    @param {string[]} [groups] - A list of groups you want strings for
    @returns {string[]}
*/
GuppyDoc.prototype.get_symbols = function(groups){
    var types = {};
    var ans = [];
    var groups_selector = "//f";
    if(groups) groups_selector += "[" + groups.map(function(){ return ""; }).join(" or ") + "]";
    var iterator = this.xpath_list(groups_selector)
    for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext())
        types[nn.getAttribute("type")] = true;
    for(var t in types)
        ans.push(t);
    return ans;
}

/** 
    Set the content of the document
    @memberof GuppyDoc
    @param {string} xml_data - An XML string representing the content of the document
*/
GuppyDoc.prototype.set_content = function(xml_data){
    this.base = (new window.DOMParser()).parseFromString(xml_data, "text/xml");
    this.ensure_text_nodes();
}

GuppyDoc.bracket_xpath = "(count(./*) != 1 and not \
                  ( \
                            count(./e)=2 and \
                count(./f)=1 and \
                count(./e[string-length(text())=0])=2 and \
                ( \
                  (\
                                count(./f/c)=1 and\
                    count(./f/c[@is_bracket='yes'])=1\
                  )\
                  or\
                  (\
                    f/@char='yes' and \
                count(./e[@current='yes'])=0 and \
                count(./e[@temp='yes'])=0 \
                  )\
                )\
              )\
            )  \
            or\
                (\
              count(./*) = 1 and \
              string-length(./e/text()) != 1 and \
              number(./e/text()) != ./e/text() \
            ) \
            or \
                ( \
              count(./*) = 1 and \
              ./e/@current = 'yes' \
            ) \
            or \
                ( \
              count(./*) = 1 and \
              ./e/@temp = 'yes' \
            )"

GuppyDoc.prototype.manual_render = function(t,n,r){
    var ans = "";
    var nn = null;
    var i = null;
    if(n.nodeName == "e"){
        if(t == "latex" && r){
            ans = n.getAttribute("render");
        }
        else{
            ans = n.firstChild.textContent;
        }
    }
    else if(n.nodeName == "f"){
        var real_type = (t == "latex" && this.is_small(n)) ? "small_latex" : t;
        nn = this.xpath_node("./b[@p='"+real_type+"']", n) || this.xpath_node("./b[@p='"+t+"']", n);
        if(nn) ans = this.manual_render(t,nn,r);
    }
    else if(n.nodeName == "b"){
        var cs = []
        i = 1;
        var par = n.parentNode;
        for(nn = par.firstChild; nn != null; nn = nn.nextSibling)
            if(nn.nodeName == "c" || nn.nodeName == "l") cs[i++] = this.manual_render(t,nn,r);
        for(nn = n.firstChild; nn != null; nn = nn.nextSibling){
            if(nn.nodeType == 3) ans += nn.textContent;
            else if(nn.nodeType == 1){
                if(nn.hasAttribute("d")){
                    var dim = parseInt(nn.getAttribute("d"));
                    var joiner = function(d,l){
                        if(d > 1) for(var k = 0; k < l.length; k++) l[k] = joiner(d-1,l[k]);
                        return l.join(nn.getAttribute('sep'+(d-1)));
                    }
                ans += joiner(dim,cs[parseInt(nn.getAttribute("ref"))]);
                }
                else ans += cs[parseInt(nn.getAttribute("ref"))];
            }
        }
    }
    else if(n.nodeName == "l"){
        ans = [];
        i = 0;
        for(nn = n.firstChild; nn != null; nn = nn.nextSibling){
            ans[i++] = this.manual_render(t,nn,r);
        }
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
        for(nn = n.firstChild; nn != null; nn = nn.nextSibling)
            ans += this.manual_render(t,nn,r);
        if(t == "latex" && n.getAttribute("bracket") == "yes" && this.base.evaluate(GuppyDoc.bracket_xpath, n, null, XPathResult.BOOLEAN_TYPE, null).booleanValue) {
            ans = "\\left("+ans+"\\right)";
        }
    }
    return ans;
}

module.exports = GuppyDoc;

},{"./guppy_ast.js":1,"./guppy_symbols.js":3}],3:[function(require,module,exports){
var GuppySymbols = {"symbols":{}, "templates":{}};

GuppySymbols.make_template_symbol = function(template_name, name, args){
    var template = JSON.parse(JSON.stringify(GuppySymbols.templates[template_name]));
    return GuppySymbols.eval_template(template, name, args);
}

GuppySymbols.eval_template = function(template, name, args){
    args['name'] = name;
    if(Object.prototype.toString.call(template) == "[object String]") {
        var ans = template;
        for(var nam in args) {
            ans = ans.replace(new RegExp("\\{\\$"+nam+"\\}"),args[nam]);
        }
        return ans;
    }
    else {
        for(var x in template) {
            template[x] = GuppySymbols.eval_template(template[x], name, args)
        }
        return template;
    }
}

GuppySymbols.add_symbols = function(syms){
    var templates = syms["_templates"];
    if(templates){
        for(var t in templates){
            GuppySymbols.templates[t] = templates[t];
        }
        delete syms["_templates"];
    }
    for(var s in syms){
        if(syms[s].template){
            for(var v in syms[s].values){
                var name = null;
                var args = null;
                if(Object.prototype.toString.call(syms[s].values) == "[object Array]"){
                    name = syms[s].values[v];
                    args = {}
                }
                else{
                    name = v;
                    args = syms[s].values[v];
                }
                GuppySymbols.symbols[name] = GuppySymbols.make_template_symbol(syms[s].template, name, args);
            }
        }
        else{
            GuppySymbols.symbols[s] = syms[s];
        }
    }
}

GuppySymbols.symbol_to_node = function(s, content, base){
    
    // s is a symbol
    //
    // content is a list of nodes to insert
    var f = base.createElement("f");
    for(var a in s.attrs){
        f.setAttribute(a, s.attrs[a]);
    }
    if("ast" in s){
        if("type" in s.ast) f.setAttribute("ast_type",s.ast["type"])
        if("value" in s.ast) f.setAttribute("ast_value",s.ast["value"])
    }
    //if(s['char']) f.setAttribute("c","yes");
    
    var first_ref = -1;
    var refs_count = 0;
    var lists = {}
    var first;

    // Make the b nodes for rendering each output    
    for(var t in s["output"]){
        var b = base.createElement("b");
        b.setAttribute("p",t);

        var out = s["output"][t];
        if(typeof out == 'string'){
            out = out.split(/(\{\$[0-9]+(?:\{[^}]+\})*\})/g);
            for(var i = 0; i < out.length; i++){
                var m = out[i].match(/^\{\$([0-9]+)((?:\{[^}]+\})*)\}$/);
                if(m){
                    out[i] = {'ref':parseInt(m[1])};
                    if(m[2].length > 0){
                        var mm = m[2].match(/\{[^}]*\}/g);
                        out[i]['d'] = mm.length;
                        for(var j = 0; j < mm.length; j++){
                            out[i]['sep'+j] = mm[j].substring(1,mm[j].length-1);
                        }
                    }
                }
            }
        }
        for(i = 0; i < out.length; i++){
            var nt = null;
            if(typeof out[i] == 'string' || out[i] instanceof String){
                nt = base.createTextNode(out[i]);
                b.appendChild(nt);
            }
            else{
                nt = base.createElement("r");
                for(var attr in out[i]){
                    nt.setAttribute(attr,out[i][attr]);
                }
                if(t == 'latex') {
                    if(first_ref == -1) first_ref = out[i]['ref'];
                    if('d' in out[i]) lists[refs_count] = out[i]['d']
                    refs_count++;
                }
                b.appendChild(nt);
            }
        }
        f.appendChild(b);
    }
    // Now make the c nodes for storing the content
    for(i = 0; i < refs_count; i++){
        var nc = base.createElement("c");
        if(i in content){
            var node_list = content[i];
            for(var se = 0; se < node_list.length; se++){
                nc.appendChild(node_list[se].cloneNode(true));
            }
        }
        else{
            var new_e = base.createElement("e");
            new_e.appendChild(base.createTextNode(""));
            nc.appendChild(new_e);
        }
        if(i+1 == first_ref) first = nc.lastChild;
        if(s['args']){
            for(a in (s['args'][i] || {})){
                nc.setAttribute(a,s['args'][i][a]);
            }
        }
        if(i in lists){
            var par = f;
            if(i in content && content[i][0].nodeName == "l"){
                par.appendChild(content[i][0]);
            }
            else{
                for(j = 0; j < lists[i]; j++){
                    var nl = base.createElement("l");
                    nl.setAttribute("s","1");
                    par.appendChild(nl);
                    par = nl;
                    if(j == lists[i]-1) nl.appendChild(nc);
                }
            }
        }
        else f.appendChild(nc);
    }
    return {"f":f, "first":first};
}


module.exports = GuppySymbols;

},{}]},{},[2])(2)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvZ3VwcHlfYXN0LmpzIiwic3JjL2d1cHB5X2RvYy5qcyIsInNyYy9ndXBweV9zeW1ib2xzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBHdXBweUFTVCA9IHt9O1xuXG5HdXBweUFTVC50b2tlbmlzZSA9IGZ1bmN0aW9uKHMsIHRva2Vucyl7XG4gICAgdmFyIGFucyA9IFtdO1xuICAgIHdoaWxlKHMubGVuZ3RoID4gMCl7XG4gICAgICAgIHZhciBvayA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB0ID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgdmFyIHJlID0gUmVnRXhwKHQucmUpO1xuICAgICAgICAgICAgdmFyIG0gPSByZS5leGVjKHMpO1xuICAgICAgICAgICAgaWYobSl7XG4gICAgICAgICAgICAgICAgbSA9IG1bMF07XG4gICAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKG0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvayA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYodC50eXBlICE9IFwic3BhY2VcIikgYW5zLnB1c2goe1widHlwZVwiOnQudHlwZSwgXCJ2YWx1ZVwiOiB0LnZhbHVlKG0pfSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5QVNULnRva2VuaXNlX2UgPSBmdW5jdGlvbihzKXtcbiAgICByZXR1cm4gR3VwcHlBU1QudG9rZW5pc2UocywgW1xuICAgICAgICB7XCJ0eXBlXCI6XCJudW1iZXJcIiwgXCJyZVwiOlwiXlswLTkuXStcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe1xuICAgICAgICAgICAgaWYoaXNOYU4oTnVtYmVyKG0pKSkgdGhyb3cgXCJJbnZhbGlkIG51bWJlcjogXCIrbTtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobSk7XG4gICAgICAgIH19LFxuICAgICAgICB7XCJ0eXBlXCI6XCJvcGVyYXRvclwiLCBcInJlXCI6XCJeKDw9fD49fCE9fD58PHw9KVwiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcbiAgICAgICAge1widHlwZVwiOlwib3BlcmF0b3JcIiwgXCJyZVwiOlwiXlstKyovIV1cIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG4gICAgICAgIHtcInR5cGVcIjpcIm5hbWVcIiwgXCJyZVwiOlwiXlthLXpBLVpdXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgICAgICB7XCJ0eXBlXCI6XCJzcGFjZVwiLCBcInJlXCI6XCJeXFxcXHMrXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgIF0pO1xufVxuXG5HdXBweUFTVC50b19lcWxpc3QgPSBmdW5jdGlvbihhc3Qpe1xuICAgIHZhciBjb21wYXJhdG9ycyA9IFtcIj1cIixcIiE9XCIsXCI8PVwiLFwiPj1cIixcIjxcIixcIj5cIl07XG4gICAgaWYoYXN0WzFdLmxlbmd0aCA9PSAwIHx8IGNvbXBhcmF0b3JzLmluZGV4T2YoYXN0WzFdWzBdWzBdKSA8IDApIHJldHVybiBbYXN0XTtcbiAgICByZXR1cm4gR3VwcHlBU1QudG9fZXFsaXN0KGFzdFsxXVswXSkuY29uY2F0KFtbYXN0WzBdLFthc3RbMV1bMF1bMV1bMV0sYXN0WzFdWzFdXV1dKTtcbn1cblxuR3VwcHlBU1QudG9fdGV4dCA9IGZ1bmN0aW9uKGFzdCl7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IHt9O1xuICAgIGZ1bmN0aW9uc1tcImJyYWNrZXRcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcIj1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXStcIiA9IFwiK2FyZ3NbMV07fTtcbiAgICBmdW5jdGlvbnNbXCIhPVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiICE9IFwiK2FyZ3NbMV07fTtcbiAgICBmdW5jdGlvbnNbXCI8PVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiIDw9IFwiK2FyZ3NbMV07fTtcbiAgICBmdW5jdGlvbnNbXCI+PVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiID49IFwiK2FyZ3NbMV07fTtcbiAgICBmdW5jdGlvbnNbXCI8XCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3NbMF0rXCIgPCBcIithcmdzWzFdO307XG4gICAgZnVuY3Rpb25zW1wiPlwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiID4gXCIrYXJnc1sxXTt9O1xuICAgIGZ1bmN0aW9uc1tcIipcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIiAqIFwiK2FyZ3NbMV0rXCIpXCI7fTtcbiAgICBmdW5jdGlvbnNbXCIrXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCIgKyBcIithcmdzWzFdK1wiKVwiO307XG4gICAgZnVuY3Rpb25zW1wiL1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiIC8gXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcImZyYWN0aW9uXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCIgLyBcIithcmdzWzFdK1wiKVwiO307XG4gICAgZnVuY3Rpb25zW1wiLVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzLmxlbmd0aCA9PSAxID8gXCItXCIrYXJnc1swXSA6IFwiKFwiK2FyZ3NbMF0rXCIgLSBcIithcmdzWzFdK1wiKVwiO307XG4gICAgZnVuY3Rpb25zW1widmFsXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3NbMF0rXCJcIjt9O1xuICAgIGZ1bmN0aW9uc1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdO307XG4gICAgZnVuY3Rpb25zW1wic3Vic2NyaXB0XCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCJfXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcImV4cG9uZW50aWFsXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCJeXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcImZhY3RvcmlhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiKSFcIjt9O1xuICAgIGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdID0gZnVuY3Rpb24obmFtZSwgYXJncyl7cmV0dXJuIG5hbWUgKyBcIihcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIilcIjt9O1xuICAgIHJldHVybiBHdXBweUFTVC5ldmFsKGFzdCwgZnVuY3Rpb25zKTtcbn1cblxuR3VwcHlBU1QudG9feG1sID0gZnVuY3Rpb24oYXN0LCBzeW1ib2xzLCBzeW1ib2xfdG9fbm9kZSl7XG4gICAgdmFyIHByZXBlbmRfc3RyID0gZnVuY3Rpb24oZG9jLCBzdHIpe1xuICAgICAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSBzdHIgKyBkb2MuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHZhciBhcHBlbmRfc3RyID0gZnVuY3Rpb24oZG9jLCBzdHIpe1xuICAgICAgICBkb2MuZG9jdW1lbnRFbGVtZW50Lmxhc3RDaGlsZC50ZXh0Q29udGVudCArPSBzdHI7XG4gICAgfVxuICAgIHZhciBhcHBlbmRfZG9jID0gZnVuY3Rpb24oZG9jLCBkb2MyKXtcbiAgICAgICAgdmFyIG4gPSBkb2MuZG9jdW1lbnRFbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgdmFyIG5uID0gZG9jMi5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZFxuICAgICAgICBuLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgKz0gbm4uZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgZm9yKG5uID0gbm4ubmV4dFNpYmxpbmc7IG5uOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcbiAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm4uY2xvbmVOb2RlKHRydWUpLG51bGwpOyBcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZW5zdXJlX3RleHRfbm9kZXMgPSBmdW5jdGlvbihiYXNlKXtcbiAgICAgICAgdmFyIGwgPSBiYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZVwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYoIShsW2ldLmZpcnN0Q2hpbGQpKSBsW2ldLmFwcGVuZENoaWxkKGJhc2UuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBnZXRfc3ltYm9sID0gZnVuY3Rpb24obmFtZSwgc3ltYm9scyl7XG4gICAgICAgIGZvcih2YXIgcyBpbiBzeW1ib2xzKXtcbiAgICAgICAgICAgIGlmKHN5bWJvbHNbc10uYXR0cnMudHlwZSA9PSBuYW1lKSByZXR1cm4gc3ltYm9sc1tzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ2V0X2NvbnRlbnRfYXJyYXkgPSBmdW5jdGlvbihhcmdzKXtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7fTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29udGVudFtpXSA9IFtdO1xuICAgICAgICAgICAgaWYoYXJnc1tpXS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT0gXCJsXCIpIGNvbnRlbnRbaV0ucHVzaChhcmdzW2ldLmRvY3VtZW50RWxlbWVudCk7XG4gICAgICAgICAgICBlbHNlIGZvcih2YXIgbm4gPSBhcmdzW2ldLmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkOyBubjsgbm4gPSBubi5uZXh0U2libGluZykgY29udGVudFtpXS5wdXNoKG5uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgdmFyIGJpbm9wX2xvdyA9IGZ1bmN0aW9uKGFyZ3MsIG9wLCBwYXJlbnQpe1xuICAgICAgICB2YXIgZCA9IGFyZ3NbMF0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBhcHBlbmRfc3RyKGQsIG9wKTtcbiAgICAgICAgYXBwZW5kX2RvYyhkLCBhcmdzWzFdLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIGlmKHBhcmVudCAmJiAocGFyZW50WzBdID09IFwiKlwiIHx8IChwYXJlbnRbMF0gPT0gXCItXCIgJiYgcGFyZW50WzFdLmxlbmd0aCA9PSAxKSkpXG4gICAgICAgICAgICByZXR1cm4gbWFrZV9zeW0oXCJicmFja2V0XCIsIFtkXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICB2YXIgYmlub3BfaGlnaCA9IGZ1bmN0aW9uKGFyZ3MsIG9wKXtcbiAgICAgICAgdmFyIGQgPSBhcmdzWzBdLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgYXBwZW5kX2RvYyhkLCBtYWtlX3N5bShvcCxbXSkpO1xuICAgICAgICBhcHBlbmRfZG9jKGQsIGFyZ3NbMV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIHZhciBtYWtlX3N5bSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3Mpe1xuICAgICAgICB2YXIgc3ltID0gZ2V0X3N5bWJvbChuYW1lLCBzeW1ib2xzKTtcbiAgICAgICAgaWYoIXN5bSkgdGhyb3cgXCJVbnJlY29nbmlzZWQgc3ltYm9sOiBcIituYW1lO1xuICAgICAgICB2YXIgYmFzZSA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoXCI8Yz48ZT48L2U+PGU+PC9lPjwvYz5cIiwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgZW5zdXJlX3RleHRfbm9kZXMoYmFzZSk7XG4gICAgICAgIHZhciBlMCA9IGJhc2UuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBjb250ZW50ID0gZ2V0X2NvbnRlbnRfYXJyYXkoYXJncyk7XG4gICAgICAgIHZhciBmID0gc3ltYm9sX3RvX25vZGUoc3ltLCBjb250ZW50LCBiYXNlKVsnZiddO1xuICAgICAgICBlMC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLGUwLm5leHRTaWJsaW5nKTtcbiAgICAgICAgZW5zdXJlX3RleHRfbm9kZXMoYmFzZSk7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICB2YXIgZnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgb3BzID0gW1wiKlwiLFwiPFwiLFwiPlwiLFwiPVwiLFwiPD1cIixcIj49XCIsXCIhPVwiXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZnVuY3Rpb25zW29wc1tpXV0gPSBmdW5jdGlvbihvKXsgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpeyByZXR1cm4gYmlub3BfaGlnaChhcmdzLCBvKTsgfX0ob3BzW2ldKTtcbiAgICB9XG4gICAgZnVuY3Rpb25zW1wiL1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe1xuICAgICAgICByZXR1cm4gbWFrZV9zeW0oXCJmcmFjdGlvblwiLGFyZ3MpO1xuICAgIH07XG4gICAgZnVuY3Rpb25zW1wiK1wiXSA9IGZ1bmN0aW9uKGFyZ3MsIHBhcmVudCl7IHJldHVybiBiaW5vcF9sb3coYXJncywgXCIrXCIsIHBhcmVudCk7IH07XG4gICAgZnVuY3Rpb25zW1wiLVwiXSA9IGZ1bmN0aW9uKGFyZ3MsIHBhcmVudCkge1xuICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGFyZ3NbMF0uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgcHJlcGVuZF9zdHIoZCwgXCItXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmlub3BfbG93KGFyZ3MsIFwiLVwiLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uc1tcInZhbFwiXSA9IGZ1bmN0aW9uKGFyZ3MpeyByZXR1cm4gKG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyhcIjxjPjxlPlwiICsgYXJnc1swXSArIFwiPC9lPjwvYz5cIiwgXCJ0ZXh0L3htbFwiKTt9O1xuICAgIGZ1bmN0aW9uc1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe1xuICAgICAgICBpZihhcmdzWzBdLmxlbmd0aCA9PSAxKSByZXR1cm4gKG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyhcIjxjPjxlPlwiICsgYXJnc1swXSArIFwiPC9lPjwvYz5cIiwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgZWxzZSByZXR1cm4gbWFrZV9zeW0oYXJnc1swXSwge30pO1xuICAgIH07XG4gICAgZnVuY3Rpb25zW1wibGlzdFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe1xuICAgICAgICB2YXIgYmFzZSA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoXCI8bD48L2w+XCIsIFwidGV4dC94bWxcIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGJhc2UuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGFyZ3NbaV0uZG9jdW1lbnRFbGVtZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZS5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJzXCIsU3RyaW5nKGFyZ3MubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfTtcbiAgICAvLyB2YXIgY29tcGFyYXRvcnMgPSB7XCI8XCI6XCJsZXNzXCIsXCI+XCI6XCJncmVhdGVyXCIsXCI9XCI6XCJlcVwiLFwiIT1cIjpcIm5lcVwiLFwiPj1cIjpcImdlcVwiLFwiPD1cIjpcImxlcVwifTtcbiAgICAvLyBmb3IodmFyIGMgaW4gY29tcGFyYXRvcnMpe1xuICAgIC8vICAgICBmdW5jdGlvbnNbY10gPSBmdW5jdGlvbihhcmdzKXtcbiAgICAvLyAgICAgICAgIHJldHVybiBtYWtlX3N5bShjb21wYXJhdG9yc1tjXSwgYXJncyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0gPSBmdW5jdGlvbihuYW1lLCBhcmdzKXtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc3ltKG5hbWUsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgYW5zID0gR3VwcHlBU1QuZXZhbChhc3QsIGZ1bmN0aW9ucyk7XG4gICAgdmFyIG5ld19iYXNlID0gKG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyhcIjxtPjwvbT5cIiwgXCJ0ZXh0L3htbFwiKTtcbiAgICBmb3IodmFyIG5uID0gYW5zLmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkOyBubjsgbm4gPSBubi5uZXh0U2libGluZyl7XG4gICAgICAgIG5ld19iYXNlLmRvY3VtZW50RWxlbWVudC5pbnNlcnRCZWZvcmUobm4uY2xvbmVOb2RlKHRydWUpLG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3X2Jhc2U7XG5cbn1cblxuR3VwcHlBU1QuZ2V0X25vZGVzID0gZnVuY3Rpb24oYXN0LCBuYW1lKXtcbiAgICBpZihhc3QubGVuZ3RoIDwgMikgcmV0dXJuIFtdO1xuICAgIHZhciBhbnMgPSBbXTtcbiAgICBpZihhc3RbMF0gPT0gbmFtZSkgYW5zLnB1c2goYXN0WzFdKTtcbiAgICBpZihhc3RbMF0gPT0gXCJ2YXJcIiB8fCBhc3RbMF0gPT0gXCJ2YWxcIikgcmV0dXJuIGFucztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXN0WzFdLmxlbmd0aDsgaSsrKSBhbnMgPSBhbnMuY29uY2F0KEd1cHB5QVNULmdldF9ub2Rlcyhhc3RbMV1baV0sIG5hbWUpKTtcbiAgICByZXR1cm4gYW5zO1xufVxuXG5HdXBweUFTVC5nZXRfdmFycyA9IGZ1bmN0aW9uKGFzdCl7XG4gICAgdmFyIHZhcnMgPSB7fTtcbiAgICB2YXIgYW5zID0gW107XG4gICAgdmFyIGwgPSBHdXBweUFTVC5nZXRfbm9kZXMoYXN0LCBcInZhclwiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKykgdmFyc1tsW2ldWzBdXSA9IHRydWU7XG4gICAgZm9yKHZhciB4IGluIHZhcnMpIGFucy5wdXNoKHgpO1xuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5QVNULnRvX2Z1bmN0aW9uID0gZnVuY3Rpb24oYXN0LCBmdW5jdGlvbnMpe1xuICAgIGZ1bmN0aW9ucyA9IGZ1bmN0aW9ucyB8fCB7fVxuICAgIHZhciBkZWZhdWx0cyA9IHt9XG4gICAgZGVmYXVsdHNbXCIqXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpKmFyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCIrXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpK2FyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCJmcmFjdGlvblwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gYXJnc1swXSh2YXJzKS9hcmdzWzFdKHZhcnMpfTt9O1xuICAgIGRlZmF1bHRzW1wiL1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gYXJnc1swXSh2YXJzKS9hcmdzWzFdKHZhcnMpfTt9O1xuICAgIGRlZmF1bHRzW1wiLVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzLmxlbmd0aCA9PSAxID8gZnVuY3Rpb24odmFycyl7cmV0dXJuIC1hcmdzWzBdKHZhcnMpfSA6IGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpLWFyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCJ2YWxcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3NbMF07IH07fTtcbiAgICBkZWZhdWx0c1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXsgaWYoYXJnc1swXSA9PSBcInBpXCIpIHJldHVybiBNYXRoLlBJOyBpZihhcmdzWzBdID09IFwiZVwiKSByZXR1cm4gTWF0aC5FOyByZXR1cm4gdmFyc1thcmdzWzBdXTsgfTt9O1xuICAgIGRlZmF1bHRzW1wiZXhwb25lbnRpYWxcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gZnVuY3Rpb24odmFycyl7cmV0dXJuIE1hdGgucG93KGFyZ3NbMF0odmFycyksYXJnc1sxXSh2YXJzKSl9O307XG4gICAgZGVmYXVsdHNbXCJzcXVhcmVfcm9vdFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gTWF0aC5zcXJ0KGFyZ3NbMF0odmFycykpfTt9O1xuICAgIGRlZmF1bHRzW1wic2luXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBNYXRoLnNpbihhcmdzWzBdKHZhcnMpKX07fTtcbiAgICBkZWZhdWx0c1tcImNvc1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gTWF0aC5jb3MoYXJnc1swXSh2YXJzKSl9O307XG4gICAgZGVmYXVsdHNbXCJ0YW5cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gZnVuY3Rpb24odmFycyl7cmV0dXJuIE1hdGgudGFuKGFyZ3NbMF0odmFycykpfTt9O1xuICAgIGRlZmF1bHRzW1wibG9nXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBNYXRoLmxvZyhhcmdzWzBdKHZhcnMpKX07fTtcbiAgICBmb3IodmFyIG4gaW4gZGVmYXVsdHMpIGlmKCFmdW5jdGlvbnNbbl0pIGZ1bmN0aW9uc1tuXSA9IGRlZmF1bHRzW25dO1xuICAgIHJldHVybiB7XCJmdW5jdGlvblwiOkd1cHB5QVNULmV2YWwoYXN0LCBmdW5jdGlvbnMpLFwidmFyc1wiOkd1cHB5QVNULmdldF92YXJzKGFzdCl9O1xufVxuXG5HdXBweUFTVC5ldmFsID0gZnVuY3Rpb24oYXN0LCBmdW5jdGlvbnMsIHBhcmVudCl7XG4gICAgYW5zID0gbnVsbDtcbiAgICBpZighZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0pIGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdID0gZnVuY3Rpb24obmFtZSwgYXJncyl7IHRocm93IFwiRnVuY3Rpb24gbm90IGltcGxlbWVudGVkOiBcIiArIG5hbWUgKyBcIihcIiArIGFyZ3MgKyBcIilcIjt9XG4gICAgXG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhc3RbMV0ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXN0WzFdW2ldKSA9PT0gJ1tvYmplY3QgQXJyYXldJyl7XG4gICAgICAgICAgICBhcmdzLnB1c2goR3VwcHlBU1QuZXZhbChhc3RbMV1baV0sIGZ1bmN0aW9ucywgYXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhc3RbMV1baV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJGblwiLGFzdFswXSxmdW5jdGlvbnNbYXN0WzBdXSk7XG4gICAgdmFyIGFucyA9IG51bGw7XG4gICAgaWYoZnVuY3Rpb25zW2FzdFswXV0pIGFucyA9IGZ1bmN0aW9uc1thc3RbMF1dKGFyZ3MsIHBhcmVudCk7XG4gICAgZWxzZSBpZihmdW5jdGlvbnNbXCJfZGVmYXVsdFwiXSkgYW5zID0gZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0oYXN0WzBdLCBhcmdzLCBwYXJlbnQpO1xuICAgIFxuICAgIC8vY29uc29sZS5sb2coXCJFVkFMXCIsSlNPTi5zdHJpbmdpZnkoYXN0KSwnPScsYW5zKTtcbiAgICByZXR1cm4gYW5zXG59XG5cbkd1cHB5QVNULnBhcnNlX2UgPSBmdW5jdGlvbih0b2tlbnMpe1xuICAgIHZhciBzeW1ib2xfdGFibGUgPSB7fTtcblxuICAgIHZhciBvcmlnaW5hbF9zeW1ib2wgPSB7XG4gICAgICAgIG51ZDogZnVuY3Rpb24gKCkgeyB0aHJvdyBFcnJvcihcIlVuZGVmaW5lZFwiKTsgfSxcbiAgICAgICAgbGVkOiBmdW5jdGlvbiAoKSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBvcGVyYXRvclwiKTsgfVxuICAgIH07XG5cbiAgICB2YXIgbXVsID0gZnVuY3Rpb24obGVmdCl7IHJldHVybiBbXCIqXCIsIFtsZWZ0LCB0aGlzLm51ZCgpXV07IH07XG4gICAgXG4gICAgdmFyIHN5bWJvbCA9IGZ1bmN0aW9uIChpZCwgYnApIHtcbiAgICAgICAgdmFyIHMgPSBzeW1ib2xfdGFibGVbaWRdO1xuICAgICAgICBicCA9IGJwIHx8IDA7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICBpZiAoYnAgPj0gcy5sYnApIHtcbiAgICAgICAgICAgICAgICBzLmxicCA9IGJwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxfc3ltYm9sKTtcbiAgICAgICAgICAgIHMuaWQgPSBzLnZhbHVlID0gaWQ7XG4gICAgICAgICAgICBzLmxicCA9IGJwO1xuICAgICAgICAgICAgc3ltYm9sX3RhYmxlW2lkXSA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcblxuICAgIHN5bWJvbChcIihlbmQpXCIpO1xuICAgIHZhciBzID0gbnVsbDtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKGJsYW5rKVwiLCA2MCk7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpeyByZXR1cm4gW1wiYmxhbmtcIl07fTtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKGZ1bmN0aW9uKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgLy9zLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy5hcmdzIHx8IFtdLCB0aGlzLmt3YXJncyB8fCB7fV07fTtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy5hcmdzIHx8IFtdXTt9O1xuICAgIFxuICAgIHMgPSBzeW1ib2woXCIobGl0ZXJhbClcIiwgNjApO1xuICAgIHMubGVkID0gbXVsO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcInZhbFwiLCBbdGhpcy52YWx1ZV1dIH07XG5cbiAgICBzID0gc3ltYm9sKFwiKHBhc3MpXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmFyZ3NbMF0gfTtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKHZhcilcIiwgNjApO1xuICAgIHMubGVkID0gbXVsO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcInZhclwiLCBbdGhpcy52YWx1ZV1dIH07XG5cbiAgICB2YXIgdG9rZW47XG4gICAgdmFyIHRva2VuX25yID0gMDtcblxuICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhLCBvLCB0LCB2O1xuICAgICAgICBpZiAoaWQgJiYgdG9rZW4uaWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbl9uciA+PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHQgPSB0b2tlbnNbdG9rZW5fbnJdO1xuICAgICAgICB0b2tlbl9uciArPSAxO1xuICAgICAgICB2ID0gdC52YWx1ZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBudWxsO1xuICAgICAgICB2YXIga3dhcmdzID0gbnVsbDtcbiAgICAgICAgYSA9IHQudHlwZTtcbiAgICAgICAgaWYgKGEgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW1wiKHZhcilcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gXCJvcGVyYXRvclwiKSB7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW3ZdO1xuICAgICAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJVbmtub3duIG9wZXJhdG9yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gIFwicGFzc1wiKSB7XG4gICAgICAgICAgICBhID0gXCJwYXNzXCI7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW1wiKHBhc3MpXCJdO1xuICAgICAgICAgICAgYXJncyA9IHQuYXJncztcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSAgXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYSA9IFwibGl0ZXJhbFwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSAgXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhID0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihmdW5jdGlvbilcIl07XG4gICAgICAgICAgICBhcmdzID0gdC5hcmdzO1xuICAgICAgICAgICAga3dhcmdzID0gdC5rd2FyZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW5cIix0KTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IE9iamVjdC5jcmVhdGUobyk7XG4gICAgICAgIHRva2VuLnR5cGUgPSBhO1xuICAgICAgICB0b2tlbi52YWx1ZSA9IHY7XG4gICAgICAgIGlmKGFyZ3MpIHRva2VuLmFyZ3MgPSBhcmdzO1xuICAgICAgICBpZihrd2FyZ3MpIHRva2VuLmt3YXJncyA9IGt3YXJncztcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG5cblxuICAgIHZhciBleHByZXNzaW9uID0gZnVuY3Rpb24gKHJicCkge1xuICAgICAgICB2YXIgbGVmdDtcbiAgICAgICAgdmFyIHQgPSB0b2tlbjtcbiAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICBsZWZ0ID0gdC5udWQoKTtcbiAgICAgICAgd2hpbGUgKHJicCA8IHRva2VuLmxicCkge1xuICAgICAgICAgICAgdCA9IHRva2VuO1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgbGVmdCA9IHQubGVkKGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgaW5maXggPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcbiAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQsIGJwKTtcbiAgICAgICAgcy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2xlZnQsIGV4cHJlc3Npb24oYnApXV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIFxuICAgIGluZml4KFwiPVwiLCA0MCk7XG4gICAgaW5maXgoXCIhPVwiLCA0MCk7XG4gICAgaW5maXgoXCI8XCIsIDQwKTtcbiAgICBpbmZpeChcIj5cIiwgNDApO1xuICAgIGluZml4KFwiPD1cIiwgNDApO1xuICAgIGluZml4KFwiPj1cIiwgNDApO1xuXG4gICAgaW5maXgoXCIrXCIsIDUwKTtcbiAgICBpbmZpeChcIi1cIiwgNTApO1xuICAgIGluZml4KFwiKlwiLCA2MCk7XG4gICAgaW5maXgoXCIvXCIsIDYwKTtcbiAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gKGlkLCBudWQpIHtcbiAgICAgICAgdmFyIHMgPSBzeW1ib2woaWQpO1xuICAgICAgICBzLm51ZCA9IG51ZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudmFsdWUsIFtleHByZXNzaW9uKDcwKV1dO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBwcmVmaXgoXCItXCIpO1xuICAgIHByZWZpeChcIiFcIik7XG4gICAgcHJlZml4KFwidHlwZW9mXCIpO1xuXG4gICAgaWYodG9rZW5zLmxlbmd0aCA9PSAwKSByZXR1cm4gW1wiYmxhbmtcIl07XG4gICAgXG4gICAgYWR2YW5jZSgpO1xuICAgIFxuICAgIHJldHVybiBleHByZXNzaW9uKDEwKTtcbn1cblxuXG5cbkd1cHB5QVNULnRva2VuaXNlX3RleHQgPSBmdW5jdGlvbihzKXtcbiAgICByZXR1cm4gR3VwcHlBU1QudG9rZW5pc2UocywgW1xuICAgICAgICB7XCJ0eXBlXCI6XCJudW1iZXJcIiwgXCJyZVwiOlwiXlswLTkuXStcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBOdW1iZXIobSl9fSxcbiAgICAgICAge1widHlwZVwiOlwib3BlcmF0b3JcIiwgXCJyZVwiOlwiXighPXw+PXw8PSlcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtO319LFxuICAgICAgICB7XCJ0eXBlXCI6XCJvcGVyYXRvclwiLCBcInJlXCI6XCJeWy0rKi8sISgpPTw+X15dXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgICAgICB7XCJ0eXBlXCI6XCJuYW1lXCIsIFwicmVcIjpcIl5bYS16QS1aX10qW2EtekEtWl1cIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG4gICAgICAgIHtcInR5cGVcIjpcImNvbW1hXCIsIFwicmVcIjpcIl4sXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgICAgICB7XCJ0eXBlXCI6XCJzcGFjZVwiLCBcInJlXCI6XCJeXFxcXHMrXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuICAgIF0pO1xufVxuXG5HdXBweUFTVC5wYXJzZV90ZXh0ID0gZnVuY3Rpb24odG9rZW5zKXtcbiAgICB2YXIgc3ltYm9sX3RhYmxlID0ge307XG5cbiAgICB2YXIgb3JpZ2luYWxfc3ltYm9sID0ge1xuICAgICAgICBudWQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgRXJyb3IoXCJVbmRlZmluZWRcIik7IH0sXG4gICAgICAgIGxlZDogZnVuY3Rpb24gKCkgeyB0aHJvdyBFcnJvcihcIk1pc3Npbmcgb3BlcmF0b3JcIik7IH1cbiAgICB9O1xuXG4gICAgdmFyIG11bCA9IGZ1bmN0aW9uKGxlZnQpeyByZXR1cm4gW1wiKlwiLCBbbGVmdCwgdGhpcy5udWQoKV1dOyB9O1xuICAgIFxuICAgIHZhciBzeW1ib2wgPSBmdW5jdGlvbiAoaWQsIGJwKSB7XG4gICAgICAgIHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcbiAgICAgICAgYnAgPSBicCB8fCAwO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG4gICAgICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsX3N5bWJvbCk7XG4gICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICBzeW1ib2woXCIoZW5kKVwiKTtcbiAgICB2YXIgcyA9IG51bGw7XG4gICAgXG4gICAgcyA9IHN5bWJvbChcIihibGFuaylcIiwgNjApO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcImJsYW5rXCJdO307XG4gICAgXG4gICAgcyA9IHN5bWJvbChcIihsaXRlcmFsKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpeyByZXR1cm4gW1widmFsXCIsIFt0aGlzLnZhbHVlXV0gfTtcblxuICAgIHZhciBnZXRfYXJncyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGFkdmFuY2UoKVxuICAgICAgICBpZih0b2tlbi5pZCAhPT0gXCIpXCIpe1xuICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24oMCkpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5pZCAhPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkdmFuY2UoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2UoXCIpXCIpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgXG4gICAgcyA9IHN5bWJvbChcIih2YXIpXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRva2VuLmlkID09IFwiKFwiKXtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgZ2V0X2FyZ3MoKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBbXCJ2YXJcIiwgW3RoaXMudmFsdWVdXVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgdG9rZW47XG4gICAgdmFyIHRva2VuX25yID0gMDtcblxuICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhLCBvLCB0LCB2O1xuICAgICAgICBpZiAoaWQgJiYgdG9rZW4uaWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbl9uciA+PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHQgPSB0b2tlbnNbdG9rZW5fbnJdO1xuICAgICAgICB0b2tlbl9uciArPSAxO1xuICAgICAgICB2ID0gdC52YWx1ZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBudWxsO1xuICAgICAgICBhID0gdC50eXBlO1xuICAgICAgICBpZiAoYSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbXCIodmFyKVwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbdl07XG4gICAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGEgPT09ICBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBhID0gXCJsaXRlcmFsXCI7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW1wiKGxpdGVyYWwpXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuXCIsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSBPYmplY3QuY3JlYXRlKG8pO1xuICAgICAgICB0b2tlbi50eXBlID0gYTtcbiAgICAgICAgdG9rZW4udmFsdWUgPSB2O1xuICAgICAgICBpZihhcmdzKSB0b2tlbi5hcmdzID0gYXJncztcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkFEVkRcIixKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcblxuXG4gICAgdmFyIGV4cHJlc3Npb24gPSBmdW5jdGlvbiAocmJwKSB7XG4gICAgICAgIHZhciBsZWZ0O1xuICAgICAgICB2YXIgdCA9IHRva2VuO1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVDFcIixKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xuICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJUMlwiLEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgICAgIGxlZnQgPSB0Lm51ZCgpO1xuICAgICAgICB3aGlsZSAocmJwIDwgdG9rZW4ubGJwKSB7XG4gICAgICAgICAgICB0ID0gdG9rZW47XG4gICAgICAgICAgICBhZHZhbmNlKCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkJcIixKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xuICAgICAgICAgICAgbGVmdCA9IHQubGVkKGxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJQT1dcIiwgcmJwLCB0b2tlbi5pZCwgdG9rZW4ubGJwKTtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcblxuICAgIHZhciBpbmZpeCA9IGZ1bmN0aW9uIChpZCwgYnAsIGxlZCkge1xuICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCwgYnApO1xuICAgICAgICBzLmxlZCA9IGxlZCB8fCBmdW5jdGlvbiAobGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnZhbHVlLCBbbGVmdCwgZXhwcmVzc2lvbihicCldXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgaW5maXgoXCI9XCIsIDQwKTtcbiAgICBpbmZpeChcIiE9XCIsIDQwKTtcbiAgICBpbmZpeChcIjxcIiwgNDApO1xuICAgIGluZml4KFwiPlwiLCA0MCk7XG4gICAgaW5maXgoXCI8PVwiLCA0MCk7XG4gICAgaW5maXgoXCI+PVwiLCA0MCk7XG5cbiAgICBpbmZpeChcIitcIiwgNTApO1xuICAgIGluZml4KFwiLVwiLCA1MCk7XG4gICAgaW5maXgoXCIqXCIsIDYwKTtcbiAgICBpbmZpeChcIi9cIiwgNjApO1xuICAgIFxuICAgIGluZml4KFwiIVwiLCA3MCwgZnVuY3Rpb24obGVmdCl7XG4gICAgICAgIHJldHVybiBbXCJmYWN0b3JpYWxcIiwgW2xlZnRdXTtcbiAgICB9KTtcbiAgICBcbiAgICBpbmZpeChcIl5cIiwgNzAsIGZ1bmN0aW9uKGxlZnQpe1xuICAgICAgICByZXR1cm4gW1wiZXhwb25lbnRpYWxcIiwgW2xlZnQsIGV4cHJlc3Npb24oNzApXV07XG4gICAgfSk7XG4gICAgXG4gICAgaW5maXgoXCJfXCIsIDcwLCBmdW5jdGlvbihsZWZ0KXtcbiAgICAgICAgcmV0dXJuIFtcInN1YnNjcmlwdFwiLCBbbGVmdCwgZXhwcmVzc2lvbig3MCldXTtcbiAgICB9KTtcbiAgICBcbiAgICBpbmZpeChcIihcIiwgODAsIG11bCk7XG5cbiAgICBzeW1ib2woXCIoXCIpLm51ZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhbnMgPSBleHByZXNzaW9uKDApO1xuICAgICAgICBhZHZhbmNlKFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIGFucztcbiAgICB9XG4gICAgc3ltYm9sKFwiKVwiKTtcbiAgICBzeW1ib2woXCIsXCIpO1xuICAgIFxuICAgIHZhciBwcmVmaXggPSBmdW5jdGlvbiAoaWQsIG51ZCkge1xuICAgICAgICB2YXIgcyA9IHN5bWJvbChpZCk7XG4gICAgICAgIHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2V4cHJlc3Npb24oNzApXV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHByZWZpeChcIi1cIik7XG5cbiAgICBpZih0b2tlbnMubGVuZ3RoID09IDApIHJldHVybiBbXCJibGFua1wiXTtcbiAgICBcbiAgICBhZHZhbmNlKCk7XG4gICAgXG4gICAgcmV0dXJuIGV4cHJlc3Npb24oMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1cHB5QVNUO1xuIiwidmFyIEd1cHB5QVNUID0gcmVxdWlyZSgnLi9ndXBweV9hc3QuanMnKTtcbnZhciBHdXBweVN5bWJvbHMgPSByZXF1aXJlKCcuL2d1cHB5X3N5bWJvbHMuanMnKTtcblxuLyoqXG4gICBAY2xhc3NcbiAgIEBjbGFzc2Rlc2MgQSBjbGFzcyByZXByZXNlbnRpbmcgYSBHdXBweSBkb2N1bWVudFxuICAgQHBhcmFtIHtzdHJpbmd9IFtkb2M9PG0+PGU+PC9lPjwvbT5dIC0gQW4gWE1MIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRvY3VtZW50XG4gICBAY29uc3RydWN0b3IgXG4gKi9cbnZhciBHdXBweURvYyA9IGZ1bmN0aW9uKGRvYyl7XG4gICAgZG9jID0gZG9jIHx8IFwiPG0+PGU+PC9lPjwvbT5cIjtcbiAgICB0aGlzLnNldF9jb250ZW50KGRvYyk7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5pc19zbWFsbCA9IGZ1bmN0aW9uKG5uKXtcbiAgICB2YXIgbiA9IG5uLnBhcmVudE5vZGU7XG4gICAgd2hpbGUobiAhPSBudWxsICYmIG4ubm9kZU5hbWUgIT0gJ20nKXtcbiAgICAgICAgaWYobi5nZXRBdHRyaWJ1dGUoXCJzbWFsbFwiKSA9PSBcInllc1wiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbiA9IG4ucGFyZW50Tm9kZVxuICAgICAgICB3aGlsZShuICE9IG51bGwgJiYgbi5ub2RlTmFtZSAhPSAnYycpIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmVuc3VyZV90ZXh0X25vZGVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbCA9IHRoaXMuYmFzZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImVcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZighKGxbaV0uZmlyc3RDaGlsZCkpIGxbaV0uYXBwZW5kQ2hpbGQodGhpcy5iYXNlLmNyZWF0ZVRleHROb2RlKFwiXCIpKTtcbiAgICB9XG59XG5cbi8qKiBcbiAgICBDaGVjayBpZiBkb2N1bWVudCBpcyBlbXB0eVxuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEByZXR1cm5zIHtib29sZWFufVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5pc19ibGFuayA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5iYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZlwiKS5sZW5ndGggPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGwgPSB0aGlzLmJhc2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJlXCIpO1xuICAgIGlmKGwubGVuZ3RoID09IDEgJiYgKCEobFswXS5maXJzdENoaWxkKSB8fCBsWzBdLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPT0gXCJcIikpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKiogXG4gICAgR2V0IHRoZSBkb2N1bWVudCBhcyBhIERPTSBvYmplY3RcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcmV0dXJucyB7RWxlbWVudH1cbiovXG5HdXBweURvYy5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKiBcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nXG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHBhcmFtIHtzdHJpbmd9IHQgLSBUaGUgcmVuZGVyaW5nIG1ldGhvZCB0byB1c2UgKFwibGF0ZXhcIiwgXCJ0ZXh0XCIsIFwiYXN0XCIgKGZvciBzeW50YXggdHJlZSksIG9yIFwieG1sXCIgKGZvciBpbnRlcm5hbCBYTUwgcmVwcmVzZW50YXRpb24pKVxuICAgIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLmdldF9jb250ZW50ID0gZnVuY3Rpb24odCxyKXtcbiAgICBpZih0ID09IFwieG1sXCIpIHJldHVybiAobmV3IFhNTFNlcmlhbGl6ZXIoKSkuc2VyaWFsaXplVG9TdHJpbmcodGhpcy5iYXNlKTtcbiAgICBlbHNlIGlmKHQgPT0gXCJhc3RcIikgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuc3ludGF4X3RyZWUoKSk7XG4gICAgZWxzZSBpZih0ID09IFwidGV4dFwiKSByZXR1cm4gR3VwcHlBU1QudG9fdGV4dCh0aGlzLnN5bnRheF90cmVlKCkpO1xuICAgIGVsc2UgaWYodCA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBHdXBweUFTVC50b19mdW5jdGlvbih0aGlzLnN5bnRheF90cmVlKCkpO1xuICAgIGVsc2UgaWYodCA9PSBcImVxbnNcIikgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEd1cHB5QVNULnRvX2VxbGlzdCh0aGlzLnN5bnRheF90cmVlKCkpKTtcbiAgICBlbHNlIHJldHVybiB0aGlzLm1hbnVhbF9yZW5kZXIodCx0aGlzLnJvb3QoKSxyKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24oZXZhbHVhdG9ycyl7XG4gICAgcmV0dXJuIEd1cHB5QVNULmV2YWwodGhpcy5zeW50YXhfdHJlZSgpLCBldmFsdWF0b3JzKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmltcG9ydF90ZXh0ID0gZnVuY3Rpb24odGV4dCwgc3ltcywgczJuKXtcbiAgICB2YXIgdG9rZW5zID0gR3VwcHlBU1QudG9rZW5pc2VfdGV4dCh0ZXh0KTtcbiAgICB2YXIgYXN0ID0gR3VwcHlBU1QucGFyc2VfdGV4dCh0b2tlbnMpO1xuICAgIHRoaXMuaW1wb3J0X2FzdChhc3QsIHN5bXMsIHMybik7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5pbXBvcnRfYXN0ID0gZnVuY3Rpb24oYXN0LCBzeW1zLCBzMm4pe1xuICAgIHN5bXMgPSBzeW1zIHx8IEd1cHB5U3ltYm9scy5zeW1ib2xzO1xuICAgIHMybiA9IHMybiB8fCBHdXBweVN5bWJvbHMuc3ltYm9sX3RvX25vZGU7XG4gICAgdmFyIGRvYyA9IEd1cHB5QVNULnRvX3htbChhc3QsIHN5bXMsIHMybik7XG4gICAgdGhpcy5iYXNlID0gZG9jO1xuICAgIHRoaXMuZW5zdXJlX3RleHRfbm9kZXMoKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLnN5bnRheF90cmVlID0gZnVuY3Rpb24obil7XG4gICAgbiA9IG4gfHwgdGhpcy5yb290KClcbiAgICBpZihuLm5vZGVOYW1lID09IFwiZlwiKXtcbiAgICAgICAgdmFyIGFucyA9IHtcImFyZ3NcIjpbXSwgXCJrd2FyZ3NcIjp7fX07XG4gICAgICAgIGFuc1sndmFsdWUnXSA9IG4uZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcbiAgICAgICAgYW5zWyd0eXBlJ10gPSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmKG4uaGFzQXR0cmlidXRlKFwiYXN0X3ZhbHVlXCIpKSBhbnNbJ3ZhbHVlJ10gPSBuLmdldEF0dHJpYnV0ZShcImFzdF92YWx1ZVwiKTtcbiAgICAgICAgaWYobi5oYXNBdHRyaWJ1dGUoXCJhc3RfdHlwZVwiKSkgYW5zWyd0eXBlJ10gPSBuLmdldEF0dHJpYnV0ZShcImFzdF90eXBlXCIpO1xuICAgICAgICBlbHNlIGlmKG4uZ2V0QXR0cmlidXRlKFwiY2hhclwiKSA9PSBcInllc1wiKSBhbnNbJ3R5cGUnXSA9IFwibmFtZVwiO1xuICAgICAgICBcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy54cGF0aF9saXN0KFwiLi8qW25hbWUoKT0nYycgb3IgbmFtZSgpPSdsJ11cIiwgbilcbiAgICAgICAgZm9yKHZhciBubiA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCk7IG5uICE9IG51bGw7IG5uID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKSl7XG4gICAgICAgICAgICAvL2lmKG5uLmhhc0F0dHJpYnV0ZShcIm5hbWVcIikpIGFucy5rd2FyZ3Nbbm4uZ2V0QXR0cmlidXRlKFwibmFtZVwiKV0gPSB0aGlzLnN5bnRheF90cmVlKG5uKVxuICAgICAgICAgICAgLy9lbHNlIGFucy5hcmdzLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpXG4gICAgICAgICAgICBhbnMuYXJncy5wdXNoKHRoaXMuc3ludGF4X3RyZWUobm4pKVxuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJGXCIsSlNPTi5zdHJpbmdpZnkoYW5zKSlcbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwibFwiKXtcbiAgICAgICAgYW5zID0gW107XG4gICAgICAgIGZvcihubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZyl7XG4gICAgICAgIGFucy5wdXNoKHRoaXMuc3ludGF4X3RyZWUobm4pKTtcbiAgICAgICAgfVxuICAgICAgICBhbnMgPSBbXCJsaXN0XCIsYW5zXTtcbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwiY1wiIHx8IG4ubm9kZU5hbWUgPT0gXCJtXCIpe1xuICAgICAgICBpZihuLmhhc0F0dHJpYnV0ZShcIm1vZGVcIikgJiYgbi5nZXRBdHRyaWJ1dGUoXCJtb2RlXCIpID09IFwidGV4dFwiKXtcbiAgICAgICAgICAgIGFucyA9IG4uZmlyc3RDaGlsZC5maXJzdENoaWxkLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gW11cbiAgICAgICAgICAgIGZvcihubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZyl7XG4gICAgICAgICAgICAgICAgaWYobm4ubm9kZU5hbWUgPT0gXCJlXCIpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KEd1cHB5QVNULnRva2VuaXNlX2Uobm4uZmlyc3RDaGlsZC50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKG5uLm5vZGVOYW1lID09IFwiZlwiKXtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUT0tcIix0b2tlbnMpO1xuICAgICAgICAgICAgYW5zID0gR3VwcHlBU1QucGFyc2VfZSh0b2tlbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS54cGF0aF9ub2RlID0gZnVuY3Rpb24oeHBhdGgsIG5vZGUpe1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMucm9vdCgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5ldmFsdWF0ZSh4cGF0aCwgbm9kZSwgbnVsbCwgWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEUsIG51bGwpLnNpbmdsZU5vZGVWYWx1ZTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLnhwYXRoX2xpc3QgPSBmdW5jdGlvbih4cGF0aCwgbm9kZSl7XG4gICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5yb290KClcbiAgICByZXR1cm4gdGhpcy5iYXNlLmV2YWx1YXRlKHhwYXRoLCBub2RlLCBudWxsLCBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSwgbnVsbCk7XG59XG5cbi8qKiBcbiAgICBHZXQgdGhlIG5hbWVzIG9mIHN5bWJvbHMgdXNlZCBpbiB0aGlzIGRvY3VtZW50XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHBhcmFtIHtzdHJpbmdbXX0gW2dyb3Vwc10gLSBBIGxpc3Qgb2YgZ3JvdXBzIHlvdSB3YW50IHN0cmluZ3MgZm9yXG4gICAgQHJldHVybnMge3N0cmluZ1tdfVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5nZXRfc3ltYm9scyA9IGZ1bmN0aW9uKGdyb3Vwcyl7XG4gICAgdmFyIHR5cGVzID0ge307XG4gICAgdmFyIGFucyA9IFtdO1xuICAgIHZhciBncm91cHNfc2VsZWN0b3IgPSBcIi8vZlwiO1xuICAgIGlmKGdyb3VwcykgZ3JvdXBzX3NlbGVjdG9yICs9IFwiW1wiICsgZ3JvdXBzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gXCJcIjsgfSkuam9pbihcIiBvciBcIikgKyBcIl1cIjtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnhwYXRoX2xpc3QoZ3JvdXBzX3NlbGVjdG9yKVxuICAgIGZvcih2YXIgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpOyBubiAhPSBudWxsOyBubiA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCkpXG4gICAgICAgIHR5cGVzW25uLmdldEF0dHJpYnV0ZShcInR5cGVcIildID0gdHJ1ZTtcbiAgICBmb3IodmFyIHQgaW4gdHlwZXMpXG4gICAgICAgIGFucy5wdXNoKHQpO1xuICAgIHJldHVybiBhbnM7XG59XG5cbi8qKiBcbiAgICBTZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHBhcmFtIHtzdHJpbmd9IHhtbF9kYXRhIC0gQW4gWE1MIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLnNldF9jb250ZW50ID0gZnVuY3Rpb24oeG1sX2RhdGEpe1xuICAgIHRoaXMuYmFzZSA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoeG1sX2RhdGEsIFwidGV4dC94bWxcIik7XG4gICAgdGhpcy5lbnN1cmVfdGV4dF9ub2RlcygpO1xufVxuXG5HdXBweURvYy5icmFja2V0X3hwYXRoID0gXCIoY291bnQoLi8qKSAhPSAxIGFuZCBub3QgXFxcbiAgICAgICAgICAgICAgICAgICggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCguL2UpPTIgYW5kIFxcXG4gICAgICAgICAgICAgICAgY291bnQoLi9mKT0xIGFuZCBcXFxuICAgICAgICAgICAgICAgIGNvdW50KC4vZVtzdHJpbmctbGVuZ3RoKHRleHQoKSk9MF0pPTIgYW5kIFxcXG4gICAgICAgICAgICAgICAgKCBcXFxuICAgICAgICAgICAgICAgICAgKFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50KC4vZi9jKT0xIGFuZFxcXG4gICAgICAgICAgICAgICAgICAgIGNvdW50KC4vZi9jW0Bpc19icmFja2V0PSd5ZXMnXSk9MVxcXG4gICAgICAgICAgICAgICAgICApXFxcbiAgICAgICAgICAgICAgICAgIG9yXFxcbiAgICAgICAgICAgICAgICAgIChcXFxuICAgICAgICAgICAgICAgICAgICBmL0BjaGFyPSd5ZXMnIGFuZCBcXFxuICAgICAgICAgICAgICAgIGNvdW50KC4vZVtAY3VycmVudD0neWVzJ10pPTAgYW5kIFxcXG4gICAgICAgICAgICAgICAgY291bnQoLi9lW0B0ZW1wPSd5ZXMnXSk9MCBcXFxuICAgICAgICAgICAgICAgICAgKVxcXG4gICAgICAgICAgICAgICAgKVxcXG4gICAgICAgICAgICAgIClcXFxuICAgICAgICAgICAgKSAgXFxcbiAgICAgICAgICAgIG9yXFxcbiAgICAgICAgICAgICAgICAoXFxcbiAgICAgICAgICAgICAgY291bnQoLi8qKSA9IDEgYW5kIFxcXG4gICAgICAgICAgICAgIHN0cmluZy1sZW5ndGgoLi9lL3RleHQoKSkgIT0gMSBhbmQgXFxcbiAgICAgICAgICAgICAgbnVtYmVyKC4vZS90ZXh0KCkpICE9IC4vZS90ZXh0KCkgXFxcbiAgICAgICAgICAgICkgXFxcbiAgICAgICAgICAgIG9yIFxcXG4gICAgICAgICAgICAgICAgKCBcXFxuICAgICAgICAgICAgICBjb3VudCguLyopID0gMSBhbmQgXFxcbiAgICAgICAgICAgICAgLi9lL0BjdXJyZW50ID0gJ3llcycgXFxcbiAgICAgICAgICAgICkgXFxcbiAgICAgICAgICAgIG9yIFxcXG4gICAgICAgICAgICAgICAgKCBcXFxuICAgICAgICAgICAgICBjb3VudCguLyopID0gMSBhbmQgXFxcbiAgICAgICAgICAgICAgLi9lL0B0ZW1wID0gJ3llcycgXFxcbiAgICAgICAgICAgIClcIlxuXG5HdXBweURvYy5wcm90b3R5cGUubWFudWFsX3JlbmRlciA9IGZ1bmN0aW9uKHQsbixyKXtcbiAgICB2YXIgYW5zID0gXCJcIjtcbiAgICB2YXIgbm4gPSBudWxsO1xuICAgIHZhciBpID0gbnVsbDtcbiAgICBpZihuLm5vZGVOYW1lID09IFwiZVwiKXtcbiAgICAgICAgaWYodCA9PSBcImxhdGV4XCIgJiYgcil7XG4gICAgICAgICAgICBhbnMgPSBuLmdldEF0dHJpYnV0ZShcInJlbmRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgYW5zID0gbi5maXJzdENoaWxkLnRleHRDb250ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImZcIil7XG4gICAgICAgIHZhciByZWFsX3R5cGUgPSAodCA9PSBcImxhdGV4XCIgJiYgdGhpcy5pc19zbWFsbChuKSkgPyBcInNtYWxsX2xhdGV4XCIgOiB0O1xuICAgICAgICBubiA9IHRoaXMueHBhdGhfbm9kZShcIi4vYltAcD0nXCIrcmVhbF90eXBlK1wiJ11cIiwgbikgfHwgdGhpcy54cGF0aF9ub2RlKFwiLi9iW0BwPSdcIit0K1wiJ11cIiwgbik7XG4gICAgICAgIGlmKG5uKSBhbnMgPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwiYlwiKXtcbiAgICAgICAgdmFyIGNzID0gW11cbiAgICAgICAgaSA9IDE7XG4gICAgICAgIHZhciBwYXIgPSBuLnBhcmVudE5vZGU7XG4gICAgICAgIGZvcihubiA9IHBhci5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgaWYobm4ubm9kZU5hbWUgPT0gXCJjXCIgfHwgbm4ubm9kZU5hbWUgPT0gXCJsXCIpIGNzW2krK10gPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcbiAgICAgICAgZm9yKG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcbiAgICAgICAgICAgIGlmKG5uLm5vZGVUeXBlID09IDMpIGFucyArPSBubi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGVsc2UgaWYobm4ubm9kZVR5cGUgPT0gMSl7XG4gICAgICAgICAgICAgICAgaWYobm4uaGFzQXR0cmlidXRlKFwiZFwiKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBwYXJzZUludChubi5nZXRBdHRyaWJ1dGUoXCJkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW5lciA9IGZ1bmN0aW9uKGQsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID4gMSkgZm9yKHZhciBrID0gMDsgayA8IGwubGVuZ3RoOyBrKyspIGxba10gPSBqb2luZXIoZC0xLGxba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuam9pbihubi5nZXRBdHRyaWJ1dGUoJ3NlcCcrKGQtMSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFucyArPSBqb2luZXIoZGltLGNzW3BhcnNlSW50KG5uLmdldEF0dHJpYnV0ZShcInJlZlwiKSldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBhbnMgKz0gY3NbcGFyc2VJbnQobm4uZ2V0QXR0cmlidXRlKFwicmVmXCIpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwibFwiKXtcbiAgICAgICAgYW5zID0gW107XG4gICAgICAgIGkgPSAwO1xuICAgICAgICBmb3Iobm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuICAgICAgICAgICAgYW5zW2krK10gPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJjXCIgfHwgbi5ub2RlTmFtZSA9PSBcIm1cIil7XG4gICAgICAgIGZvcihubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZylcbiAgICAgICAgICAgIGFucyArPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcbiAgICAgICAgaWYodCA9PSBcImxhdGV4XCIgJiYgbi5nZXRBdHRyaWJ1dGUoXCJicmFja2V0XCIpID09IFwieWVzXCIgJiYgdGhpcy5iYXNlLmV2YWx1YXRlKEd1cHB5RG9jLmJyYWNrZXRfeHBhdGgsIG4sIG51bGwsIFhQYXRoUmVzdWx0LkJPT0xFQU5fVFlQRSwgbnVsbCkuYm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICBhbnMgPSBcIlxcXFxsZWZ0KFwiK2FucytcIlxcXFxyaWdodClcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1cHB5RG9jO1xuIiwidmFyIEd1cHB5U3ltYm9scyA9IHtcInN5bWJvbHNcIjp7fSwgXCJ0ZW1wbGF0ZXNcIjp7fX07XG5cbkd1cHB5U3ltYm9scy5tYWtlX3RlbXBsYXRlX3N5bWJvbCA9IGZ1bmN0aW9uKHRlbXBsYXRlX25hbWUsIG5hbWUsIGFyZ3Mpe1xuICAgIHZhciB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoR3VwcHlTeW1ib2xzLnRlbXBsYXRlc1t0ZW1wbGF0ZV9uYW1lXSkpO1xuICAgIHJldHVybiBHdXBweVN5bWJvbHMuZXZhbF90ZW1wbGF0ZSh0ZW1wbGF0ZSwgbmFtZSwgYXJncyk7XG59XG5cbkd1cHB5U3ltYm9scy5ldmFsX3RlbXBsYXRlID0gZnVuY3Rpb24odGVtcGxhdGUsIG5hbWUsIGFyZ3Mpe1xuICAgIGFyZ3NbJ25hbWUnXSA9IG5hbWU7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRlbXBsYXRlKSA9PSBcIltvYmplY3QgU3RyaW5nXVwiKSB7XG4gICAgICAgIHZhciBhbnMgPSB0ZW1wbGF0ZTtcbiAgICAgICAgZm9yKHZhciBuYW0gaW4gYXJncykge1xuICAgICAgICAgICAgYW5zID0gYW5zLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFx7XFxcXCRcIituYW0rXCJcXFxcfVwiKSxhcmdzW25hbV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IodmFyIHggaW4gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlW3hdID0gR3VwcHlTeW1ib2xzLmV2YWxfdGVtcGxhdGUodGVtcGxhdGVbeF0sIG5hbWUsIGFyZ3MpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbn1cblxuR3VwcHlTeW1ib2xzLmFkZF9zeW1ib2xzID0gZnVuY3Rpb24oc3ltcyl7XG4gICAgdmFyIHRlbXBsYXRlcyA9IHN5bXNbXCJfdGVtcGxhdGVzXCJdO1xuICAgIGlmKHRlbXBsYXRlcyl7XG4gICAgICAgIGZvcih2YXIgdCBpbiB0ZW1wbGF0ZXMpe1xuICAgICAgICAgICAgR3VwcHlTeW1ib2xzLnRlbXBsYXRlc1t0XSA9IHRlbXBsYXRlc1t0XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3ltc1tcIl90ZW1wbGF0ZXNcIl07XG4gICAgfVxuICAgIGZvcih2YXIgcyBpbiBzeW1zKXtcbiAgICAgICAgaWYoc3ltc1tzXS50ZW1wbGF0ZSl7XG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gc3ltc1tzXS52YWx1ZXMpe1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bXNbc10udmFsdWVzKSA9PSBcIltvYmplY3QgQXJyYXldXCIpe1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gc3ltc1tzXS52YWx1ZXNbdl07XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdjtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHN5bXNbc10udmFsdWVzW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBHdXBweVN5bWJvbHMuc3ltYm9sc1tuYW1lXSA9IEd1cHB5U3ltYm9scy5tYWtlX3RlbXBsYXRlX3N5bWJvbChzeW1zW3NdLnRlbXBsYXRlLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgR3VwcHlTeW1ib2xzLnN5bWJvbHNbc10gPSBzeW1zW3NdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5HdXBweVN5bWJvbHMuc3ltYm9sX3RvX25vZGUgPSBmdW5jdGlvbihzLCBjb250ZW50LCBiYXNlKXtcbiAgICBcbiAgICAvLyBzIGlzIGEgc3ltYm9sXG4gICAgLy9cbiAgICAvLyBjb250ZW50IGlzIGEgbGlzdCBvZiBub2RlcyB0byBpbnNlcnRcbiAgICB2YXIgZiA9IGJhc2UuY3JlYXRlRWxlbWVudChcImZcIik7XG4gICAgZm9yKHZhciBhIGluIHMuYXR0cnMpe1xuICAgICAgICBmLnNldEF0dHJpYnV0ZShhLCBzLmF0dHJzW2FdKTtcbiAgICB9XG4gICAgaWYoXCJhc3RcIiBpbiBzKXtcbiAgICAgICAgaWYoXCJ0eXBlXCIgaW4gcy5hc3QpIGYuc2V0QXR0cmlidXRlKFwiYXN0X3R5cGVcIixzLmFzdFtcInR5cGVcIl0pXG4gICAgICAgIGlmKFwidmFsdWVcIiBpbiBzLmFzdCkgZi5zZXRBdHRyaWJ1dGUoXCJhc3RfdmFsdWVcIixzLmFzdFtcInZhbHVlXCJdKVxuICAgIH1cbiAgICAvL2lmKHNbJ2NoYXInXSkgZi5zZXRBdHRyaWJ1dGUoXCJjXCIsXCJ5ZXNcIik7XG4gICAgXG4gICAgdmFyIGZpcnN0X3JlZiA9IC0xO1xuICAgIHZhciByZWZzX2NvdW50ID0gMDtcbiAgICB2YXIgbGlzdHMgPSB7fVxuICAgIHZhciBmaXJzdDtcblxuICAgIC8vIE1ha2UgdGhlIGIgbm9kZXMgZm9yIHJlbmRlcmluZyBlYWNoIG91dHB1dCAgICBcbiAgICBmb3IodmFyIHQgaW4gc1tcIm91dHB1dFwiXSl7XG4gICAgICAgIHZhciBiID0gYmFzZS5jcmVhdGVFbGVtZW50KFwiYlwiKTtcbiAgICAgICAgYi5zZXRBdHRyaWJ1dGUoXCJwXCIsdCk7XG5cbiAgICAgICAgdmFyIG91dCA9IHNbXCJvdXRwdXRcIl1bdF07XG4gICAgICAgIGlmKHR5cGVvZiBvdXQgPT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgb3V0ID0gb3V0LnNwbGl0KC8oXFx7XFwkWzAtOV0rKD86XFx7W159XStcXH0pKlxcfSkvZyk7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG91dFtpXS5tYXRjaCgvXlxce1xcJChbMC05XSspKCg/Olxce1tefV0rXFx9KSopXFx9JC8pO1xuICAgICAgICAgICAgICAgIGlmKG0pe1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gPSB7J3JlZic6cGFyc2VJbnQobVsxXSl9O1xuICAgICAgICAgICAgICAgICAgICBpZihtWzJdLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1tID0gbVsyXS5tYXRjaCgvXFx7W159XSpcXH0vZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbaV1bJ2QnXSA9IG1tLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBtbS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldWydzZXAnK2pdID0gbW1bal0uc3Vic3RyaW5nKDEsbW1bal0ubGVuZ3RoLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYodHlwZW9mIG91dFtpXSA9PSAnc3RyaW5nJyB8fCBvdXRbaV0gaW5zdGFuY2VvZiBTdHJpbmcpe1xuICAgICAgICAgICAgICAgIG50ID0gYmFzZS5jcmVhdGVUZXh0Tm9kZShvdXRbaV0pO1xuICAgICAgICAgICAgICAgIGIuYXBwZW5kQ2hpbGQobnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBudCA9IGJhc2UuY3JlYXRlRWxlbWVudChcInJcIik7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBhdHRyIGluIG91dFtpXSl7XG4gICAgICAgICAgICAgICAgICAgIG50LnNldEF0dHJpYnV0ZShhdHRyLG91dFtpXVthdHRyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHQgPT0gJ2xhdGV4Jykge1xuICAgICAgICAgICAgICAgICAgICBpZihmaXJzdF9yZWYgPT0gLTEpIGZpcnN0X3JlZiA9IG91dFtpXVsncmVmJ107XG4gICAgICAgICAgICAgICAgICAgIGlmKCdkJyBpbiBvdXRbaV0pIGxpc3RzW3JlZnNfY291bnRdID0gb3V0W2ldWydkJ11cbiAgICAgICAgICAgICAgICAgICAgcmVmc19jb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiLmFwcGVuZENoaWxkKG50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmLmFwcGVuZENoaWxkKGIpO1xuICAgIH1cbiAgICAvLyBOb3cgbWFrZSB0aGUgYyBub2RlcyBmb3Igc3RvcmluZyB0aGUgY29udGVudFxuICAgIGZvcihpID0gMDsgaSA8IHJlZnNfY291bnQ7IGkrKyl7XG4gICAgICAgIHZhciBuYyA9IGJhc2UuY3JlYXRlRWxlbWVudChcImNcIik7XG4gICAgICAgIGlmKGkgaW4gY29udGVudCl7XG4gICAgICAgICAgICB2YXIgbm9kZV9saXN0ID0gY29udGVudFtpXTtcbiAgICAgICAgICAgIGZvcih2YXIgc2UgPSAwOyBzZSA8IG5vZGVfbGlzdC5sZW5ndGg7IHNlKyspe1xuICAgICAgICAgICAgICAgIG5jLmFwcGVuZENoaWxkKG5vZGVfbGlzdFtzZV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdmFyIG5ld19lID0gYmFzZS5jcmVhdGVFbGVtZW50KFwiZVwiKTtcbiAgICAgICAgICAgIG5ld19lLmFwcGVuZENoaWxkKGJhc2UuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuICAgICAgICAgICAgbmMuYXBwZW5kQ2hpbGQobmV3X2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGkrMSA9PSBmaXJzdF9yZWYpIGZpcnN0ID0gbmMubGFzdENoaWxkO1xuICAgICAgICBpZihzWydhcmdzJ10pe1xuICAgICAgICAgICAgZm9yKGEgaW4gKHNbJ2FyZ3MnXVtpXSB8fCB7fSkpe1xuICAgICAgICAgICAgICAgIG5jLnNldEF0dHJpYnV0ZShhLHNbJ2FyZ3MnXVtpXVthXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoaSBpbiBsaXN0cyl7XG4gICAgICAgICAgICB2YXIgcGFyID0gZjtcbiAgICAgICAgICAgIGlmKGkgaW4gY29udGVudCAmJiBjb250ZW50W2ldWzBdLm5vZGVOYW1lID09IFwibFwiKXtcbiAgICAgICAgICAgICAgICBwYXIuYXBwZW5kQ2hpbGQoY29udGVudFtpXVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGxpc3RzW2ldOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSBiYXNlLmNyZWF0ZUVsZW1lbnQoXCJsXCIpO1xuICAgICAgICAgICAgICAgICAgICBubC5zZXRBdHRyaWJ1dGUoXCJzXCIsXCIxXCIpO1xuICAgICAgICAgICAgICAgICAgICBwYXIuYXBwZW5kQ2hpbGQobmwpO1xuICAgICAgICAgICAgICAgICAgICBwYXIgPSBubDtcbiAgICAgICAgICAgICAgICAgICAgaWYoaiA9PSBsaXN0c1tpXS0xKSBubC5hcHBlbmRDaGlsZChuYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgZi5hcHBlbmRDaGlsZChuYyk7XG4gICAgfVxuICAgIHJldHVybiB7XCJmXCI6ZiwgXCJmaXJzdFwiOmZpcnN0fTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1cHB5U3ltYm9scztcbiJdfQ==
