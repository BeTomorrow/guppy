(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GuppyDoc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
   @class
   @classdesc A class representing a Guppy document
   @param {string} [doc=<m><e></e></m>] - An XML string representing the document
   @constructor 
 */
var GuppyDoc = function(doc){
    doc = doc || "<m><e></e></m>";
    this.set_content(doc);
}

GuppyDoc.prototype.is_small = function(nn){
    var n = nn.parentNode;
    while(n != null && n.nodeName != 'm'){
	if(n.getAttribute("small") == "yes") return true;
	n = n.parentNode
	while(n != null && n.nodeName != 'c') n = n.parentNode;
    }
    return false;
}

GuppyDoc.prototype.ensure_text_nodes = function(){
    var l = this.base.getElementsByTagName("e");
    for(var i = 0; i < l.length; i++){
	if(!(l[i].firstChild)) l[i].appendChild(this.base.createTextNode(""));
    }
}

/** 
    Check if document is empty
    @memberof GuppyDoc
    @returns {boolean}
*/
GuppyDoc.prototype.is_blank = function(){
    if(this.base.getElementsByTagName("f").length > 0) return false;
    var l = this.base.getElementsByTagName("e");
    if(l.length == 1 && (!(l[0].firstChild) || l[0].firstChild.textContent == "")) return true;
    return false;
}


/** 
    Get the document as a DOM object
    @memberof GuppyDoc
    @returns {Element}
*/
GuppyDoc.prototype.root = function(){
    return this.base.documentElement;
}

/** 
    Get the content of the document as a string
    @memberof GuppyDoc
    @param {string} t - The rendering method to use ("latex", "text", "ast" (for syntax tree), or "xml" (for internal XML representation))
    @returns {string}
*/
GuppyDoc.prototype.get_content = function(t,r){
    if(t == "xml") return (new XMLSerializer()).serializeToString(this.base);
    else if(t == "ast") return JSON.stringify(this.syntax_tree());
    else if(t == "text") return GuppyDoc.to_text(this.syntax_tree());
    else return this.manual_render(t,this.root(),r);
}

GuppyDoc.prototype.syntax_tree = function(n){
    n = n || this.root()
    if(n.nodeName == "e"){
	console.log("Should never happen");
	//ans = n.firstChild.textContent;
    }
    else if(n.nodeName == "f"){
	var ans = {"args":[], "kwargs":{}};
	ans['value'] = n.getAttribute("type");
	ans['type'] = "function";
	if(n.hasAttribute("ast_value")) ans['value'] = n.getAttribute("ast_value");
	if(n.hasAttribute("ast_type")) ans['type'] = n.getAttribute("ast_type");
	else if(n.getAttribute("char") == "yes") ans['type'] = "name";
	
	var iterator = this.xpath_list("./*[name()='c' or name()='l']", n)
	for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext()){
	    //if(nn.hasAttribute("name")) ans.kwargs[nn.getAttribute("name")] = this.syntax_tree(nn)
	    //ans.args.push(this.syntax_tree(nn))
	    ans.args.push(this.syntax_tree(nn))
	}
    }
    else if(n.nodeName == "l"){
	ans = [];
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans.push(this.syntax_tree(nn));
	}
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	var tokens = []
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    if(nn.nodeName == "e"){
		tokens = tokens.concat(GuppyDoc.tokenise(nn.firstChild.textContent));
	    }
	    else if(nn.nodeName == "f"){
		tokens.push(this.syntax_tree(nn));
	    }
	}
	ans = GuppyDoc.parse(tokens);
    }
    return ans;
}

GuppyDoc.prototype.xpath_node = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

GuppyDoc.prototype.xpath_list = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
}

/** 
    Get the names of symbols used in this document
    @memberof GuppyDoc
    @param {string[]} [groups] - A list of groups you want strings for
    @returns {string[]}
*/
GuppyDoc.prototype.get_symbols = function(groups){
    var types = {};
    var ans = [];
    var iterator = groups ? this.xpath_list("//f") : this.xpath_list("//f[@group='"+groups[i]+"']");
    for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext())
	types[nn.getAttribute("type")] = true;
    for(var t in types)
	ans.push(t);
    return ans;
}

/** 
    Set the content of the document
    @memberof GuppyDoc
    @param {string} xml_data - An XML string representing the content of the document
*/
GuppyDoc.prototype.set_content = function(xml_data){
    this.base = (new window.DOMParser()).parseFromString(xml_data, "text/xml");
    this.ensure_text_nodes();
}

GuppyDoc.bracket_xpath = "(count(./*) != 1 and not \
		          ( \
                            count(./e)=2 and \
			    count(./f)=1 and \
			    count(./e[string-length(text())=0])=2 and \
			    ( \
			      (\
                                count(./f/c)=1 and\
			        count(./f/c[@is_bracket='yes'])=1\
			      )\
			      or\
			      (\
			        f/@c='yes' and \
				count(./e[@current='yes'])=0 and \
				count(./e[@temp='yes'])=0 \
			      )\
			    )\
			  )\
			)  \
			or\
		        (\
			  count(./*) = 1 and \
			  string-length(./e/text()) != 1 and \
			  number(./e/text()) != ./e/text() \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@current = 'yes' \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@temp = 'yes' \
			)"

GuppyDoc.prototype.manual_render = function(t,n,r){
    var ans = "";
    if(n.nodeName == "e"){
	if(t == "latex" && r){
	    ans = n.getAttribute("render");
	}
	else if(t == "text"){
	    ans = n.firstChild.textContent;
	    if(n.previousSibling && n.nextSibling && ans == "")
		ans = " * ";
	    else {
		ans = ans.replace(/(.)([^a-zA-Z0-9.])(.)/g,"$1 $2 $3");
		ans = ans.replace(/([a-zA-Z])(?=\.)/g,"$1 * ");
		ans = ans.replace(/(\.)(?=[a-zA-Z])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z])(?=[a-zA-Z0-9])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z0-9])(?=[a-zA-Z])/g,"$1 * ");
		if(n.previousSibling && n.previousSibling.getAttribute("group") != "operations") ans = ans.replace(/^([a-zA-Z0-9])/g," * $1");
		if(n.nextSibling && n.nextSibling.getAttribute("group") != "operations") ans = ans.replace(/([a-zA-Z0-9])$/g,"$1 * ");
		ans = " "+ans+" ";
	    }
	}
	else{
	    ans = n.firstChild.textContent;
	}
    }
    else if(n.nodeName == "f"){
	var real_type = (t == "latex" && this.is_small(n)) ? "small_latex" : t;
	var nn = this.xpath_node("./b[@p='"+real_type+"']", n) || this.xpath_node("./b[@p='"+t+"']", n);
	if(nn) ans = this.manual_render(t,nn,r);
    }
    else if(n.nodeName == "b"){
	var cs = []
	var i = 1;
	var par = n.parentNode;
	for(var nn = par.firstChild; nn != null; nn = nn.nextSibling)
	    if(nn.nodeName == "c" || nn.nodeName == "l") cs[i++] = this.manual_render(t,nn,r);
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    if(nn.nodeType == 3) ans += nn.textContent;
	    else if(nn.nodeType == 1){
		if(nn.hasAttribute("d")){
		    var dim = parseInt(nn.getAttribute("d"));
		    var joiner = function(d,l){
			if(d > 1) for(var k = 0; k < l.length; k++) l[k] = joiner(d-1,l[k]);
			return l.join(nn.getAttribute('sep'+(d-1)));
		    }
		    ans += joiner(dim,cs[parseInt(nn.getAttribute("ref"))]);
		}
		else ans += cs[parseInt(nn.getAttribute("ref"))];
	    }
	}
    }
    else if(n.nodeName == "l"){
	ans = [];
	var i = 0;
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans[i++] = this.manual_render(t,nn,r);
	}
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling)
	    ans += this.manual_render(t,nn,r);
	if(t == "latex" &&
           n.getAttribute("bracket") == "yes" &&
	   this.base.evaluate(GuppyDoc.bracket_xpath, n, null,
			 XPathResult.BOOLEAN_TYPE, null).booleanValue){ 
	    ans = "\\left("+ans+"\\right)";
	}
    }
    return ans;
}

GuppyDoc.prototype.path_to = function(n){
    var name = n.nodeName;
    if(name == "m") return "guppy_loc_m";
    var ns = 0;
    for(var nn = n; nn != null; nn = nn.previousSibling) if(nn.nodeType == 1 && nn.nodeName == name) ns++;
    return this.path_to(n.parentNode)+"_"+name+""+ns;
}

GuppyDoc.tokenise = function(s){
    var tokens = [
	{"type":"number", "re":"^[0-9]+(\\.[0-9]+)?", "value":function(m){return Number(m)}},
	{"type":"operator", "re":"^[\-+*/!]", "value":function(m){return m}},
	{"type":"name", "re":"^[a-zA-Z]", "value":function(m){return m}},
	{"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ];
    var ans = [];
    while(s.length > 0){
	var ok = false;
	for(var i = 0; i < tokens.length; i++){
	    var t = tokens[i];
	    re = RegExp(t.re);
	    var m = re.exec(s);
	    if(m){
		m = m[0];
		s = s.substring(m.length);
		ok = true;
		if(t.type != "space") ans.push({"type":t.type, "value": t.value(m)})
		break;
	    }
	}
	if(!ok){
	    console.log("Tokenising error");
	    return [];
	}
    }
    return ans;
}

GuppyDoc.to_text = function(ast){
    functions = {}
    functions["*"] = function(args){return "("+args[0]+" * "+args[1]+")";}
    functions["+"] = function(args){return "("+args[0]+" + "+args[1]+")";}
    functions["/"] = function(args){return "("+args[0]+" / "+args[1]+")";}
    functions["-"] = function(args){return args.length == 1 ? "-"+args[0] : "("+args[0]+" - "+args[1]+")";}
    functions["val"] = function(args){return args[0];}
    functions["var"] = function(args){return args[0];}
    functions["exponential"] = function(args){return "("+args[0]+"^"+args[1]+")";}
    functions["factorial"] = function(args){return "("+args[0]+")!";}
    functions["_default"] = function(name, args){return name + "(" + args.join(",") + ")";}
    return GuppyDoc.eval(ast, functions);
}

GuppyDoc.eval = function(ast, functions, vars){
    ans = null;
    console.log("EVAL",JSON.stringify(ast));
    if(!functions["*"]) functions["*"] = function(args){return args[0]*args[1];}
    if(!functions["+"]) functions["+"] = function(args){return args[0]+args[1];}
    if(!functions["/"]) functions["/"] = function(args){if(args[1] == 0) throw Exception("Divide by zero"); return args[0]/args[1];}
    if(!functions["-"]) functions["-"] = function(args){return args.length == 1 ? -args[0] : args[0]-args[1];}
    if(!functions["val"]) functions["val"] = function(args){return args[0];}
    if(!functions["var"] && vars) functions["var"] = function(args){return vars[args[0]];}
    if(!functions["_default"]) functions["_default"] = function(name, args){ throw Exception("Function not implemented: " + name);}
    
    var args = []
    for(var i = 0; i < ast[1].length; i++){
	if(Object.prototype.toString.call(ast[1][i]) === '[object Array]'){
	    args.push(GuppyDoc.eval(ast[1][i], functions, vars));
	}
	else{
	    args.push(ast[1][i]);
	}
    }
    if(functions[ast[0]]) ans = functions[ast[0]](args);
    else if(functions["_default"]) ans = functions["_default"](ast[0], args);
    
    console.log("EVAL",JSON.stringify(ast),'=',ans);
    return ans
}

GuppyDoc.parse = function(tokens){
    var symbol_table = {};

    var original_symbol = {
	nud: function () { throw Error("Undefined"); },
	led: function (left) { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
	var s = symbol_table[id];
	bp = bp || 0;
	if (s) {
            if (bp >= s.lbp) {
		s.lbp = bp;
            }
	} else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
	}
	return s;
    };

    symbol("(end)");

    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(function)", 60);
    s.led = mul;
    //s.nud = function(){ return [this.value, this.args || [], this.kwargs || {}];};
    s.nud = function(){ return [this.value, this.args || []];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){ return ["var", [this.value]] };

    var token;
    var token_nr = 0;

    var advance = function (id) {
	var a, o, t, v;
	if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
	}
	if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
	}
	t = tokens[token_nr];
	token_nr += 1;
	v = t.value;
	var args = null;
	var kwargs = null;
	a = t.type;
	if (a === "name") {
            o = symbol_table["(var)"];
	} else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
		t.error("Unknown operator.");
            }
	} else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
	} else if (a ===  "function") {
            a = "function";
            o = symbol_table["(function)"];
	    args = t.args;
	    kwargs = t.kwargs;
	} else {
            throw Error("Unexpected token",t);
	}
	token = Object.create(o);
	token.type = a;
	token.value = v;
	if(args) token.args = args;
	if(kwargs) token.kwargs = kwargs;
	return token;
    };


    var expression = function (rbp) {
	var left;
	var t = token;
	advance();
	left = t.nud();
	while (rbp < token.lbp) {
            t = token;
            advance();
            left = t.led(left);
	}
	return left;
    };

    var infix = function (id, bp, led) {
	var s = symbol(id, bp);
	s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
	};
	return s;
    }

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    var prefix = function (id, nud) {
	var s = symbol(id);
	s.nud = nud || function () {
            return [this.value, [expression(70)]];
	};
	return s;
    }

    prefix("-");
    prefix("!");
    prefix("typeof");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}

module.exports = GuppyDoc;

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsInNyYy9ndXBweV9kb2MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAgIEBjbGFzc1xuICAgQGNsYXNzZGVzYyBBIGNsYXNzIHJlcHJlc2VudGluZyBhIEd1cHB5IGRvY3VtZW50XG4gICBAcGFyYW0ge3N0cmluZ30gW2RvYz08bT48ZT48L2U+PC9tPl0gLSBBbiBYTUwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZG9jdW1lbnRcbiAgIEBjb25zdHJ1Y3RvciBcbiAqL1xudmFyIEd1cHB5RG9jID0gZnVuY3Rpb24oZG9jKXtcbiAgICBkb2MgPSBkb2MgfHwgXCI8bT48ZT48L2U+PC9tPlwiO1xuICAgIHRoaXMuc2V0X2NvbnRlbnQoZG9jKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmlzX3NtYWxsID0gZnVuY3Rpb24obm4pe1xuICAgIHZhciBuID0gbm4ucGFyZW50Tm9kZTtcbiAgICB3aGlsZShuICE9IG51bGwgJiYgbi5ub2RlTmFtZSAhPSAnbScpe1xuXHRpZihuLmdldEF0dHJpYnV0ZShcInNtYWxsXCIpID09IFwieWVzXCIpIHJldHVybiB0cnVlO1xuXHRuID0gbi5wYXJlbnROb2RlXG5cdHdoaWxlKG4gIT0gbnVsbCAmJiBuLm5vZGVOYW1lICE9ICdjJykgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUuZW5zdXJlX3RleHRfbm9kZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gdGhpcy5iYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZVwiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKyl7XG5cdGlmKCEobFtpXS5maXJzdENoaWxkKSkgbFtpXS5hcHBlbmRDaGlsZCh0aGlzLmJhc2UuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuICAgIH1cbn1cblxuLyoqIFxuICAgIENoZWNrIGlmIGRvY3VtZW50IGlzIGVtcHR5XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHJldHVybnMge2Jvb2xlYW59XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLmlzX2JsYW5rID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmJhc2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmXCIpLmxlbmd0aCA+IDApIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbCA9IHRoaXMuYmFzZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImVcIik7XG4gICAgaWYobC5sZW5ndGggPT0gMSAmJiAoIShsWzBdLmZpcnN0Q2hpbGQpIHx8IGxbMF0uZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9PSBcIlwiKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKiBcbiAgICBHZXQgdGhlIGRvY3VtZW50IGFzIGEgRE9NIG9iamVjdFxuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEByZXR1cm5zIHtFbGVtZW50fVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5iYXNlLmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqIFxuICAgIEdldCB0aGUgY29udGVudCBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmdcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcGFyYW0ge3N0cmluZ30gdCAtIFRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIHVzZSAoXCJsYXRleFwiLCBcInRleHRcIiwgXCJhc3RcIiAoZm9yIHN5bnRheCB0cmVlKSwgb3IgXCJ4bWxcIiAoZm9yIGludGVybmFsIFhNTCByZXByZXNlbnRhdGlvbikpXG4gICAgQHJldHVybnMge3N0cmluZ31cbiovXG5HdXBweURvYy5wcm90b3R5cGUuZ2V0X2NvbnRlbnQgPSBmdW5jdGlvbih0LHIpe1xuICAgIGlmKHQgPT0gXCJ4bWxcIikgcmV0dXJuIChuZXcgWE1MU2VyaWFsaXplcigpKS5zZXJpYWxpemVUb1N0cmluZyh0aGlzLmJhc2UpO1xuICAgIGVsc2UgaWYodCA9PSBcImFzdFwiKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zeW50YXhfdHJlZSgpKTtcbiAgICBlbHNlIGlmKHQgPT0gXCJ0ZXh0XCIpIHJldHVybiBHdXBweURvYy50b190ZXh0KHRoaXMuc3ludGF4X3RyZWUoKSk7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5tYW51YWxfcmVuZGVyKHQsdGhpcy5yb290KCkscik7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5zeW50YXhfdHJlZSA9IGZ1bmN0aW9uKG4pe1xuICAgIG4gPSBuIHx8IHRoaXMucm9vdCgpXG4gICAgaWYobi5ub2RlTmFtZSA9PSBcImVcIil7XG5cdGNvbnNvbGUubG9nKFwiU2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcblx0Ly9hbnMgPSBuLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImZcIil7XG5cdHZhciBhbnMgPSB7XCJhcmdzXCI6W10sIFwia3dhcmdzXCI6e319O1xuXHRhbnNbJ3ZhbHVlJ10gPSBuLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cdGFuc1sndHlwZSddID0gXCJmdW5jdGlvblwiO1xuXHRpZihuLmhhc0F0dHJpYnV0ZShcImFzdF92YWx1ZVwiKSkgYW5zWyd2YWx1ZSddID0gbi5nZXRBdHRyaWJ1dGUoXCJhc3RfdmFsdWVcIik7XG5cdGlmKG4uaGFzQXR0cmlidXRlKFwiYXN0X3R5cGVcIikpIGFuc1sndHlwZSddID0gbi5nZXRBdHRyaWJ1dGUoXCJhc3RfdHlwZVwiKTtcblx0ZWxzZSBpZihuLmdldEF0dHJpYnV0ZShcImNoYXJcIikgPT0gXCJ5ZXNcIikgYW5zWyd0eXBlJ10gPSBcIm5hbWVcIjtcblx0XG5cdHZhciBpdGVyYXRvciA9IHRoaXMueHBhdGhfbGlzdChcIi4vKltuYW1lKCk9J2MnIG9yIG5hbWUoKT0nbCddXCIsIG4pXG5cdGZvcih2YXIgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpOyBubiAhPSBudWxsOyBubiA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCkpe1xuXHQgICAgLy9pZihubi5oYXNBdHRyaWJ1dGUoXCJuYW1lXCIpKSBhbnMua3dhcmdzW25uLmdldEF0dHJpYnV0ZShcIm5hbWVcIildID0gdGhpcy5zeW50YXhfdHJlZShubilcblx0ICAgIC8vYW5zLmFyZ3MucHVzaCh0aGlzLnN5bnRheF90cmVlKG5uKSlcblx0ICAgIGFucy5hcmdzLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpXG5cdH1cbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwibFwiKXtcblx0YW5zID0gW107XG5cdGZvcih2YXIgbm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuXHQgICAgYW5zLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpO1xuXHR9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImNcIiB8fCBuLm5vZGVOYW1lID09IFwibVwiKXtcblx0dmFyIHRva2VucyA9IFtdXG5cdGZvcih2YXIgbm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuXHQgICAgaWYobm4ubm9kZU5hbWUgPT0gXCJlXCIpe1xuXHRcdHRva2VucyA9IHRva2Vucy5jb25jYXQoR3VwcHlEb2MudG9rZW5pc2Uobm4uZmlyc3RDaGlsZC50ZXh0Q29udGVudCkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZihubi5ub2RlTmFtZSA9PSBcImZcIil7XG5cdFx0dG9rZW5zLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpO1xuXHQgICAgfVxuXHR9XG5cdGFucyA9IEd1cHB5RG9jLnBhcnNlKHRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS54cGF0aF9ub2RlID0gZnVuY3Rpb24oeHBhdGgsIG5vZGUpe1xuICAgIG5vZGUgPSBub2RlIHx8IHRoaXMucm9vdCgpXG4gICAgcmV0dXJuIHRoaXMuYmFzZS5ldmFsdWF0ZSh4cGF0aCwgbm9kZSwgbnVsbCwgWFBhdGhSZXN1bHQuRklSU1RfT1JERVJFRF9OT0RFX1RZUEUsIG51bGwpLnNpbmdsZU5vZGVWYWx1ZTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLnhwYXRoX2xpc3QgPSBmdW5jdGlvbih4cGF0aCwgbm9kZSl7XG4gICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5yb290KClcbiAgICByZXR1cm4gdGhpcy5iYXNlLmV2YWx1YXRlKHhwYXRoLCBub2RlLCBudWxsLCBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSwgbnVsbCk7XG59XG5cbi8qKiBcbiAgICBHZXQgdGhlIG5hbWVzIG9mIHN5bWJvbHMgdXNlZCBpbiB0aGlzIGRvY3VtZW50XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHBhcmFtIHtzdHJpbmdbXX0gW2dyb3Vwc10gLSBBIGxpc3Qgb2YgZ3JvdXBzIHlvdSB3YW50IHN0cmluZ3MgZm9yXG4gICAgQHJldHVybnMge3N0cmluZ1tdfVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5nZXRfc3ltYm9scyA9IGZ1bmN0aW9uKGdyb3Vwcyl7XG4gICAgdmFyIHR5cGVzID0ge307XG4gICAgdmFyIGFucyA9IFtdO1xuICAgIHZhciBpdGVyYXRvciA9IGdyb3VwcyA/IHRoaXMueHBhdGhfbGlzdChcIi8vZlwiKSA6IHRoaXMueHBhdGhfbGlzdChcIi8vZltAZ3JvdXA9J1wiK2dyb3Vwc1tpXStcIiddXCIpO1xuICAgIGZvcih2YXIgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpOyBubiAhPSBudWxsOyBubiA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCkpXG5cdHR5cGVzW25uLmdldEF0dHJpYnV0ZShcInR5cGVcIildID0gdHJ1ZTtcbiAgICBmb3IodmFyIHQgaW4gdHlwZXMpXG5cdGFucy5wdXNoKHQpO1xuICAgIHJldHVybiBhbnM7XG59XG5cbi8qKiBcbiAgICBTZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHBhcmFtIHtzdHJpbmd9IHhtbF9kYXRhIC0gQW4gWE1MIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIGRvY3VtZW50XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLnNldF9jb250ZW50ID0gZnVuY3Rpb24oeG1sX2RhdGEpe1xuICAgIHRoaXMuYmFzZSA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoeG1sX2RhdGEsIFwidGV4dC94bWxcIik7XG4gICAgdGhpcy5lbnN1cmVfdGV4dF9ub2RlcygpO1xufVxuXG5HdXBweURvYy5icmFja2V0X3hwYXRoID0gXCIoY291bnQoLi8qKSAhPSAxIGFuZCBub3QgXFxcblx0XHQgICAgICAgICAgKCBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50KC4vZSk9MiBhbmQgXFxcblx0XHRcdCAgICBjb3VudCguL2YpPTEgYW5kIFxcXG5cdFx0XHQgICAgY291bnQoLi9lW3N0cmluZy1sZW5ndGgodGV4dCgpKT0wXSk9MiBhbmQgXFxcblx0XHRcdCAgICAoIFxcXG5cdFx0XHQgICAgICAoXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQoLi9mL2MpPTEgYW5kXFxcblx0XHRcdCAgICAgICAgY291bnQoLi9mL2NbQGlzX2JyYWNrZXQ9J3llcyddKT0xXFxcblx0XHRcdCAgICAgIClcXFxuXHRcdFx0ICAgICAgb3JcXFxuXHRcdFx0ICAgICAgKFxcXG5cdFx0XHQgICAgICAgIGYvQGM9J3llcycgYW5kIFxcXG5cdFx0XHRcdGNvdW50KC4vZVtAY3VycmVudD0neWVzJ10pPTAgYW5kIFxcXG5cdFx0XHRcdGNvdW50KC4vZVtAdGVtcD0neWVzJ10pPTAgXFxcblx0XHRcdCAgICAgIClcXFxuXHRcdFx0ICAgIClcXFxuXHRcdFx0ICApXFxcblx0XHRcdCkgIFxcXG5cdFx0XHRvclxcXG5cdFx0ICAgICAgICAoXFxcblx0XHRcdCAgY291bnQoLi8qKSA9IDEgYW5kIFxcXG5cdFx0XHQgIHN0cmluZy1sZW5ndGgoLi9lL3RleHQoKSkgIT0gMSBhbmQgXFxcblx0XHRcdCAgbnVtYmVyKC4vZS90ZXh0KCkpICE9IC4vZS90ZXh0KCkgXFxcblx0XHRcdCkgXFxcblx0XHRcdG9yIFxcXG5cdFx0ICAgICAgICAoIFxcXG5cdFx0XHQgIGNvdW50KC4vKikgPSAxIGFuZCBcXFxuXHRcdFx0ICAuL2UvQGN1cnJlbnQgPSAneWVzJyBcXFxuXHRcdFx0KSBcXFxuXHRcdFx0b3IgXFxcblx0XHQgICAgICAgICggXFxcblx0XHRcdCAgY291bnQoLi8qKSA9IDEgYW5kIFxcXG5cdFx0XHQgIC4vZS9AdGVtcCA9ICd5ZXMnIFxcXG5cdFx0XHQpXCJcblxuR3VwcHlEb2MucHJvdG90eXBlLm1hbnVhbF9yZW5kZXIgPSBmdW5jdGlvbih0LG4scil7XG4gICAgdmFyIGFucyA9IFwiXCI7XG4gICAgaWYobi5ub2RlTmFtZSA9PSBcImVcIil7XG5cdGlmKHQgPT0gXCJsYXRleFwiICYmIHIpe1xuXHQgICAgYW5zID0gbi5nZXRBdHRyaWJ1dGUoXCJyZW5kZXJcIik7XG5cdH1cblx0ZWxzZSBpZih0ID09IFwidGV4dFwiKXtcblx0ICAgIGFucyA9IG4uZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcblx0ICAgIGlmKG4ucHJldmlvdXNTaWJsaW5nICYmIG4ubmV4dFNpYmxpbmcgJiYgYW5zID09IFwiXCIpXG5cdFx0YW5zID0gXCIgKiBcIjtcblx0ICAgIGVsc2Uge1xuXHRcdGFucyA9IGFucy5yZXBsYWNlKC8oLikoW15hLXpBLVowLTkuXSkoLikvZyxcIiQxICQyICQzXCIpO1xuXHRcdGFucyA9IGFucy5yZXBsYWNlKC8oW2EtekEtWl0pKD89XFwuKS9nLFwiJDEgKiBcIik7XG5cdFx0YW5zID0gYW5zLnJlcGxhY2UoLyhcXC4pKD89W2EtekEtWl0pL2csXCIkMSAqIFwiKTtcblx0XHRhbnMgPSBhbnMucmVwbGFjZSgvKFthLXpBLVpdKSg/PVthLXpBLVowLTldKS9nLFwiJDEgKiBcIik7XG5cdFx0YW5zID0gYW5zLnJlcGxhY2UoLyhbYS16QS1aMC05XSkoPz1bYS16QS1aXSkvZyxcIiQxICogXCIpO1xuXHRcdGlmKG4ucHJldmlvdXNTaWJsaW5nICYmIG4ucHJldmlvdXNTaWJsaW5nLmdldEF0dHJpYnV0ZShcImdyb3VwXCIpICE9IFwib3BlcmF0aW9uc1wiKSBhbnMgPSBhbnMucmVwbGFjZSgvXihbYS16QS1aMC05XSkvZyxcIiAqICQxXCIpO1xuXHRcdGlmKG4ubmV4dFNpYmxpbmcgJiYgbi5uZXh0U2libGluZy5nZXRBdHRyaWJ1dGUoXCJncm91cFwiKSAhPSBcIm9wZXJhdGlvbnNcIikgYW5zID0gYW5zLnJlcGxhY2UoLyhbYS16QS1aMC05XSkkL2csXCIkMSAqIFwiKTtcblx0XHRhbnMgPSBcIiBcIithbnMrXCIgXCI7XG5cdCAgICB9XG5cdH1cblx0ZWxzZXtcblx0ICAgIGFucyA9IG4uZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcblx0fVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJmXCIpe1xuXHR2YXIgcmVhbF90eXBlID0gKHQgPT0gXCJsYXRleFwiICYmIHRoaXMuaXNfc21hbGwobikpID8gXCJzbWFsbF9sYXRleFwiIDogdDtcblx0dmFyIG5uID0gdGhpcy54cGF0aF9ub2RlKFwiLi9iW0BwPSdcIityZWFsX3R5cGUrXCInXVwiLCBuKSB8fCB0aGlzLnhwYXRoX25vZGUoXCIuL2JbQHA9J1wiK3QrXCInXVwiLCBuKTtcblx0aWYobm4pIGFucyA9IHRoaXMubWFudWFsX3JlbmRlcih0LG5uLHIpO1xuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJiXCIpe1xuXHR2YXIgY3MgPSBbXVxuXHR2YXIgaSA9IDE7XG5cdHZhciBwYXIgPSBuLnBhcmVudE5vZGU7XG5cdGZvcih2YXIgbm4gPSBwYXIuZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZylcblx0ICAgIGlmKG5uLm5vZGVOYW1lID09IFwiY1wiIHx8IG5uLm5vZGVOYW1lID09IFwibFwiKSBjc1tpKytdID0gdGhpcy5tYW51YWxfcmVuZGVyKHQsbm4scik7XG5cdGZvcih2YXIgbm4gPSBuLmZpcnN0Q2hpbGQ7IG5uICE9IG51bGw7IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuXHQgICAgaWYobm4ubm9kZVR5cGUgPT0gMykgYW5zICs9IG5uLnRleHRDb250ZW50O1xuXHQgICAgZWxzZSBpZihubi5ub2RlVHlwZSA9PSAxKXtcblx0XHRpZihubi5oYXNBdHRyaWJ1dGUoXCJkXCIpKXtcblx0XHQgICAgdmFyIGRpbSA9IHBhcnNlSW50KG5uLmdldEF0dHJpYnV0ZShcImRcIikpO1xuXHRcdCAgICB2YXIgam9pbmVyID0gZnVuY3Rpb24oZCxsKXtcblx0XHRcdGlmKGQgPiAxKSBmb3IodmFyIGsgPSAwOyBrIDwgbC5sZW5ndGg7IGsrKykgbFtrXSA9IGpvaW5lcihkLTEsbFtrXSk7XG5cdFx0XHRyZXR1cm4gbC5qb2luKG5uLmdldEF0dHJpYnV0ZSgnc2VwJysoZC0xKSkpO1xuXHRcdCAgICB9XG5cdFx0ICAgIGFucyArPSBqb2luZXIoZGltLGNzW3BhcnNlSW50KG5uLmdldEF0dHJpYnV0ZShcInJlZlwiKSldKTtcblx0XHR9XG5cdFx0ZWxzZSBhbnMgKz0gY3NbcGFyc2VJbnQobm4uZ2V0QXR0cmlidXRlKFwicmVmXCIpKV07XG5cdCAgICB9XG5cdH1cbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwibFwiKXtcblx0YW5zID0gW107XG5cdHZhciBpID0gMDtcblx0Zm9yKHZhciBubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZyl7XG5cdCAgICBhbnNbaSsrXSA9IHRoaXMubWFudWFsX3JlbmRlcih0LG5uLHIpO1xuXHR9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImNcIiB8fCBuLm5vZGVOYW1lID09IFwibVwiKXtcblx0Zm9yKHZhciBubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZylcblx0ICAgIGFucyArPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcblx0aWYodCA9PSBcImxhdGV4XCIgJiZcbiAgICAgICAgICAgbi5nZXRBdHRyaWJ1dGUoXCJicmFja2V0XCIpID09IFwieWVzXCIgJiZcblx0ICAgdGhpcy5iYXNlLmV2YWx1YXRlKEd1cHB5RG9jLmJyYWNrZXRfeHBhdGgsIG4sIG51bGwsXG5cdFx0XHQgWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFLCBudWxsKS5ib29sZWFuVmFsdWUpeyBcblx0ICAgIGFucyA9IFwiXFxcXGxlZnQoXCIrYW5zK1wiXFxcXHJpZ2h0KVwiO1xuXHR9XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5wYXRoX3RvID0gZnVuY3Rpb24obil7XG4gICAgdmFyIG5hbWUgPSBuLm5vZGVOYW1lO1xuICAgIGlmKG5hbWUgPT0gXCJtXCIpIHJldHVybiBcImd1cHB5X2xvY19tXCI7XG4gICAgdmFyIG5zID0gMDtcbiAgICBmb3IodmFyIG5uID0gbjsgbm4gIT0gbnVsbDsgbm4gPSBubi5wcmV2aW91c1NpYmxpbmcpIGlmKG5uLm5vZGVUeXBlID09IDEgJiYgbm4ubm9kZU5hbWUgPT0gbmFtZSkgbnMrKztcbiAgICByZXR1cm4gdGhpcy5wYXRoX3RvKG4ucGFyZW50Tm9kZSkrXCJfXCIrbmFtZStcIlwiK25zO1xufVxuXG5HdXBweURvYy50b2tlbmlzZSA9IGZ1bmN0aW9uKHMpe1xuICAgIHZhciB0b2tlbnMgPSBbXG5cdHtcInR5cGVcIjpcIm51bWJlclwiLCBcInJlXCI6XCJeWzAtOV0rKFxcXFwuWzAtOV0rKT9cIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBOdW1iZXIobSl9fSxcblx0e1widHlwZVwiOlwib3BlcmF0b3JcIiwgXCJyZVwiOlwiXltcXC0rKi8hXVwiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcblx0e1widHlwZVwiOlwibmFtZVwiLCBcInJlXCI6XCJeW2EtekEtWl1cIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG5cdHtcInR5cGVcIjpcInNwYWNlXCIsIFwicmVcIjpcIl5cXFxccytcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG4gICAgXTtcbiAgICB2YXIgYW5zID0gW107XG4gICAgd2hpbGUocy5sZW5ndGggPiAwKXtcblx0dmFyIG9rID0gZmFsc2U7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspe1xuXHQgICAgdmFyIHQgPSB0b2tlbnNbaV07XG5cdCAgICByZSA9IFJlZ0V4cCh0LnJlKTtcblx0ICAgIHZhciBtID0gcmUuZXhlYyhzKTtcblx0ICAgIGlmKG0pe1xuXHRcdG0gPSBtWzBdO1xuXHRcdHMgPSBzLnN1YnN0cmluZyhtLmxlbmd0aCk7XG5cdFx0b2sgPSB0cnVlO1xuXHRcdGlmKHQudHlwZSAhPSBcInNwYWNlXCIpIGFucy5wdXNoKHtcInR5cGVcIjp0LnR5cGUsIFwidmFsdWVcIjogdC52YWx1ZShtKX0pXG5cdFx0YnJlYWs7XG5cdCAgICB9XG5cdH1cblx0aWYoIW9rKXtcblx0ICAgIGNvbnNvbGUubG9nKFwiVG9rZW5pc2luZyBlcnJvclwiKTtcblx0ICAgIHJldHVybiBbXTtcblx0fVxuICAgIH1cbiAgICByZXR1cm4gYW5zO1xufVxuXG5HdXBweURvYy50b190ZXh0ID0gZnVuY3Rpb24oYXN0KXtcbiAgICBmdW5jdGlvbnMgPSB7fVxuICAgIGZ1bmN0aW9uc1tcIipcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIiAqIFwiK2FyZ3NbMV0rXCIpXCI7fVxuICAgIGZ1bmN0aW9uc1tcIitcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIiArIFwiK2FyZ3NbMV0rXCIpXCI7fVxuICAgIGZ1bmN0aW9uc1tcIi9cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIiAvIFwiK2FyZ3NbMV0rXCIpXCI7fVxuICAgIGZ1bmN0aW9uc1tcIi1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJncy5sZW5ndGggPT0gMSA/IFwiLVwiK2FyZ3NbMF0gOiBcIihcIithcmdzWzBdK1wiIC0gXCIrYXJnc1sxXStcIilcIjt9XG4gICAgZnVuY3Rpb25zW1widmFsXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3NbMF07fVxuICAgIGZ1bmN0aW9uc1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdO31cbiAgICBmdW5jdGlvbnNbXCJleHBvbmVudGlhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiXlwiK2FyZ3NbMV0rXCIpXCI7fVxuICAgIGZ1bmN0aW9uc1tcImZhY3RvcmlhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiKSFcIjt9XG4gICAgZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0gPSBmdW5jdGlvbihuYW1lLCBhcmdzKXtyZXR1cm4gbmFtZSArIFwiKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKVwiO31cbiAgICByZXR1cm4gR3VwcHlEb2MuZXZhbChhc3QsIGZ1bmN0aW9ucyk7XG59XG5cbkd1cHB5RG9jLmV2YWwgPSBmdW5jdGlvbihhc3QsIGZ1bmN0aW9ucywgdmFycyl7XG4gICAgYW5zID0gbnVsbDtcbiAgICBjb25zb2xlLmxvZyhcIkVWQUxcIixKU09OLnN0cmluZ2lmeShhc3QpKTtcbiAgICBpZighZnVuY3Rpb25zW1wiKlwiXSkgZnVuY3Rpb25zW1wiKlwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdKmFyZ3NbMV07fVxuICAgIGlmKCFmdW5jdGlvbnNbXCIrXCJdKSBmdW5jdGlvbnNbXCIrXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3NbMF0rYXJnc1sxXTt9XG4gICAgaWYoIWZ1bmN0aW9uc1tcIi9cIl0pIGZ1bmN0aW9uc1tcIi9cIl0gPSBmdW5jdGlvbihhcmdzKXtpZihhcmdzWzFdID09IDApIHRocm93IEV4Y2VwdGlvbihcIkRpdmlkZSBieSB6ZXJvXCIpOyByZXR1cm4gYXJnc1swXS9hcmdzWzFdO31cbiAgICBpZighZnVuY3Rpb25zW1wiLVwiXSkgZnVuY3Rpb25zW1wiLVwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzLmxlbmd0aCA9PSAxID8gLWFyZ3NbMF0gOiBhcmdzWzBdLWFyZ3NbMV07fVxuICAgIGlmKCFmdW5jdGlvbnNbXCJ2YWxcIl0pIGZ1bmN0aW9uc1tcInZhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdO31cbiAgICBpZighZnVuY3Rpb25zW1widmFyXCJdICYmIHZhcnMpIGZ1bmN0aW9uc1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiB2YXJzW2FyZ3NbMF1dO31cbiAgICBpZighZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0pIGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdID0gZnVuY3Rpb24obmFtZSwgYXJncyl7IHRocm93IEV4Y2VwdGlvbihcIkZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZDogXCIgKyBuYW1lKTt9XG4gICAgXG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhc3RbMV0ubGVuZ3RoOyBpKyspe1xuXHRpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXN0WzFdW2ldKSA9PT0gJ1tvYmplY3QgQXJyYXldJyl7XG5cdCAgICBhcmdzLnB1c2goR3VwcHlEb2MuZXZhbChhc3RbMV1baV0sIGZ1bmN0aW9ucywgdmFycykpO1xuXHR9XG5cdGVsc2V7XG5cdCAgICBhcmdzLnB1c2goYXN0WzFdW2ldKTtcblx0fVxuICAgIH1cbiAgICBpZihmdW5jdGlvbnNbYXN0WzBdXSkgYW5zID0gZnVuY3Rpb25zW2FzdFswXV0oYXJncyk7XG4gICAgZWxzZSBpZihmdW5jdGlvbnNbXCJfZGVmYXVsdFwiXSkgYW5zID0gZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0oYXN0WzBdLCBhcmdzKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIkVWQUxcIixKU09OLnN0cmluZ2lmeShhc3QpLCc9JyxhbnMpO1xuICAgIHJldHVybiBhbnNcbn1cblxuR3VwcHlEb2MucGFyc2UgPSBmdW5jdGlvbih0b2tlbnMpe1xuICAgIHZhciBzeW1ib2xfdGFibGUgPSB7fTtcblxuICAgIHZhciBvcmlnaW5hbF9zeW1ib2wgPSB7XG5cdG51ZDogZnVuY3Rpb24gKCkgeyB0aHJvdyBFcnJvcihcIlVuZGVmaW5lZFwiKTsgfSxcblx0bGVkOiBmdW5jdGlvbiAobGVmdCkgeyB0aHJvdyBFcnJvcihcIk1pc3Npbmcgb3BlcmF0b3JcIik7IH1cbiAgICB9O1xuXG4gICAgdmFyIG11bCA9IGZ1bmN0aW9uKGxlZnQpeyByZXR1cm4gW1wiKlwiLCBbbGVmdCwgdGhpcy5udWQoKV1dOyB9O1xuICAgIFxuICAgIHZhciBzeW1ib2wgPSBmdW5jdGlvbiAoaWQsIGJwKSB7XG5cdHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcblx0YnAgPSBicCB8fCAwO1xuXHRpZiAocykge1xuICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG5cdFx0cy5sYnAgPSBicDtcbiAgICAgICAgICAgIH1cblx0fSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsX3N5bWJvbCk7XG4gICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuXHR9XG5cdHJldHVybiBzO1xuICAgIH07XG5cbiAgICBzeW1ib2woXCIoZW5kKVwiKTtcblxuICAgIHMgPSBzeW1ib2woXCIoYmxhbmspXCIsIDYwKTtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbXCJibGFua1wiXTt9O1xuICAgIFxuICAgIHMgPSBzeW1ib2woXCIoZnVuY3Rpb24pXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICAvL3MubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFt0aGlzLnZhbHVlLCB0aGlzLmFyZ3MgfHwgW10sIHRoaXMua3dhcmdzIHx8IHt9XTt9O1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFt0aGlzLnZhbHVlLCB0aGlzLmFyZ3MgfHwgW11dO307XG4gICAgXG4gICAgcyA9IHN5bWJvbChcIihsaXRlcmFsKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpeyByZXR1cm4gW1widmFsXCIsIFt0aGlzLnZhbHVlXV0gfTtcblxuICAgIHMgPSBzeW1ib2woXCIodmFyKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpeyByZXR1cm4gW1widmFyXCIsIFt0aGlzLnZhbHVlXV0gfTtcblxuICAgIHZhciB0b2tlbjtcbiAgICB2YXIgdG9rZW5fbnIgPSAwO1xuXG4gICAgdmFyIGFkdmFuY2UgPSBmdW5jdGlvbiAoaWQpIHtcblx0dmFyIGEsIG8sIHQsIHY7XG5cdGlmIChpZCAmJiB0b2tlbi5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWQgKyBcIidcIik7XG5cdH1cblx0aWYgKHRva2VuX25yID49IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRva2VuID0gc3ltYm9sX3RhYmxlW1wiKGVuZClcIl07XG4gICAgICAgICAgICByZXR1cm47XG5cdH1cblx0dCA9IHRva2Vuc1t0b2tlbl9ucl07XG5cdHRva2VuX25yICs9IDE7XG5cdHYgPSB0LnZhbHVlO1xuXHR2YXIgYXJncyA9IG51bGw7XG5cdHZhciBrd2FyZ3MgPSBudWxsO1xuXHRhID0gdC50eXBlO1xuXHRpZiAoYSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbXCIodmFyKVwiXTtcblx0fSBlbHNlIGlmIChhID09PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbdl07XG4gICAgICAgICAgICBpZiAoIW8pIHtcblx0XHR0LmVycm9yKFwiVW5rbm93biBvcGVyYXRvci5cIik7XG4gICAgICAgICAgICB9XG5cdH0gZWxzZSBpZiAoYSA9PT0gIFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGEgPSBcImxpdGVyYWxcIjtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbXCIobGl0ZXJhbClcIl07XG5cdH0gZWxzZSBpZiAoYSA9PT0gIFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYSA9IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbXCIoZnVuY3Rpb24pXCJdO1xuXHQgICAgYXJncyA9IHQuYXJncztcblx0ICAgIGt3YXJncyA9IHQua3dhcmdzO1xuXHR9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuXCIsdCk7XG5cdH1cblx0dG9rZW4gPSBPYmplY3QuY3JlYXRlKG8pO1xuXHR0b2tlbi50eXBlID0gYTtcblx0dG9rZW4udmFsdWUgPSB2O1xuXHRpZihhcmdzKSB0b2tlbi5hcmdzID0gYXJncztcblx0aWYoa3dhcmdzKSB0b2tlbi5rd2FyZ3MgPSBrd2FyZ3M7XG5cdHJldHVybiB0b2tlbjtcbiAgICB9O1xuXG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChyYnApIHtcblx0dmFyIGxlZnQ7XG5cdHZhciB0ID0gdG9rZW47XG5cdGFkdmFuY2UoKTtcblx0bGVmdCA9IHQubnVkKCk7XG5cdHdoaWxlIChyYnAgPCB0b2tlbi5sYnApIHtcbiAgICAgICAgICAgIHQgPSB0b2tlbjtcbiAgICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICAgIGxlZnQgPSB0LmxlZChsZWZ0KTtcblx0fVxuXHRyZXR1cm4gbGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGluZml4ID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG5cdHZhciBzID0gc3ltYm9sKGlkLCBicCk7XG5cdHMubGVkID0gbGVkIHx8IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudmFsdWUsIFtsZWZ0LCBleHByZXNzaW9uKGJwKV1dO1xuXHR9O1xuXHRyZXR1cm4gcztcbiAgICB9XG5cbiAgICBpbmZpeChcIitcIiwgNTApO1xuICAgIGluZml4KFwiLVwiLCA1MCk7XG4gICAgaW5maXgoXCIqXCIsIDYwKTtcbiAgICBpbmZpeChcIi9cIiwgNjApO1xuICAgIHZhciBwcmVmaXggPSBmdW5jdGlvbiAoaWQsIG51ZCkge1xuXHR2YXIgcyA9IHN5bWJvbChpZCk7XG5cdHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2V4cHJlc3Npb24oNzApXV07XG5cdH07XG5cdHJldHVybiBzO1xuICAgIH1cblxuICAgIHByZWZpeChcIi1cIik7XG4gICAgcHJlZml4KFwiIVwiKTtcbiAgICBwcmVmaXgoXCJ0eXBlb2ZcIik7XG5cbiAgICBpZih0b2tlbnMubGVuZ3RoID09IDApIHJldHVybiBbXCJibGFua1wiXTtcbiAgICBcbiAgICBhZHZhbmNlKCk7XG4gICAgXG4gICAgcmV0dXJuIGV4cHJlc3Npb24oMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1cHB5RG9jO1xuIl19
